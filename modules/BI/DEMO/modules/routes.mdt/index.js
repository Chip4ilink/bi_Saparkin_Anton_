/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 18:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(354);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(314);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.route-col_cell {
	position: relative !important;
	padding: 0 !important;
	min-width: 60px;
}

.route-col_wrap {
	position: absolute !important;
	height: 100%;
	width: 100%;
	display: flex;
	justify-content: center;
	align-items: flex-start;
}

.route-col_wrap .icon {
	font-size: 12px !important;
}

.route-col_val-num {
	margin: auto 4px;
}

.route-col_icon-check {
	color: var(--mdt-color-brand-success);
}

.route-col_val-many > *:nth-child(2) {
	margin-left: -4px !important;
}

.route-col_val-flag {
	color: var(--mdt-color-brand-warning);
}

.route-col_header-link {
	width: 80px;
}

.route-col_header-link > div {
	display: flex;
	align-items: center;
}

.route-col_header-link span {
	border-bottom: 1px dashed var(--mdt-body-bg);
	cursor: pointer;
}

.route-col_header-link input {
	margin-left: 8px;
	margin-top: 0;
}

.route-col_inline-cell {
	padding: 0 !important;
	position: relative !important;
}

.route-col_inline-cell > div {
	position: absolute;
	display: flex;
	height: 100%;
	width: 100%;
	align-items: center;
}

.route-col_inline-cell > div div {
	margin: 0 !important;
}

.route-col_inline-cell > div input {
	border: none;
	outline: none;
	box-shadow: none !important;
}

.route-row_incorrect_freq {
	background-color: var(--mdt-gray-elements-bg-color) !important;
}

.route-row_incorrect_freq td {
	border-color: var(--mdt-common-components-border-color) !important;
}

.route-row_incorrect_freq input {
	background: transparent !important;
}

.route-row_is-not-bound {
	background-color: #fffacf !important;
}

.route-row_is-not-bound input {
	background: transparent !important;
}

.route-row_is-not-active {
	background-color: #ff696973 !important;
}

.route-row_is-not-active input {
	background: transparent !important;
}

.route-management-total-time {
	display: flex;
	align-items: center;
	padding: 0 10px;
	white-space: nowrap;
	cursor: pointer;
}

.route-management-total-time .icon {
	margin-left: 5px;
}

@media (max-width: 1300px) {
	.route-management-page .page-block-head > h1 {
		display: none;
	}

	.route-management-page .switch-buttons_label {
		display: none !important;
	}

	.route-management-page .switch-buttons_buttons {
		margin-left: 10px;
	}
}

.select-wrapper {
	display: flex;
}

.select-wrapper .selected-info {
	margin-right: 10px;
}

.select-wrapper .select-icon {
	align-self: center;
}

.select-wrapper .calendar {
	margin-left: 10px;
}

.routes-time-transfer .common-control {
	min-width: 50px;
}

.routes-copy-to .grid {
		width: 100%;
	}

.page-header-controls .routes-cycle-picker,
.page-header-controls .routes-position-picker,
.page-header-controls .routes-time-transfer {
	margin-top: 0px;
	height: auto;
}

.page-header-controls .routes-cycle-picker .picker-control,
.page-header-controls .routes-position-picker .picker-control,
.page-header-controls .routes-time-transfer .picker-control {
	margin-top: 0px;
	height: auto;
}

.page-header-controls .routes-cycle-picker label,
.page-header-controls .routes-position-picker label,
.page-header-controls .routes-time-transfer label {
	display: inline-flex;
}

.page-header-controls .route-management-total-time .icon {
	font-size: 15px;
}

.page-header-controls .routes-cycle-picker label + div {
	width: 180px;
}

.page-header-controls .routes-position-picker label + div {
	width: 300px;
}

.page-header-controls .routes-time-transfer label + div {
	width: 60px;
}
`, "",{"version":3,"sources":["webpack://./src/styles/module.css"],"names":[],"mappings":"AAAA;CACC,6BAA6B;CAC7B,qBAAqB;CACrB,eAAe;AAChB;;AAEA;CACC,6BAA6B;CAC7B,YAAY;CACZ,WAAW;CACX,aAAa;CACb,uBAAuB;CACvB,uBAAuB;AACxB;;AAEA;CACC,0BAA0B;AAC3B;;AAEA;CACC,gBAAgB;AACjB;;AAEA;CACC,qCAAqC;AACtC;;AAEA;CACC,4BAA4B;AAC7B;;AAEA;CACC,qCAAqC;AACtC;;AAEA;CACC,WAAW;AACZ;;AAEA;CACC,aAAa;CACb,mBAAmB;AACpB;;AAEA;CACC,4CAA4C;CAC5C,eAAe;AAChB;;AAEA;CACC,gBAAgB;CAChB,aAAa;AACd;;AAEA;CACC,qBAAqB;CACrB,6BAA6B;AAC9B;;AAEA;CACC,kBAAkB;CAClB,aAAa;CACb,YAAY;CACZ,WAAW;CACX,mBAAmB;AACpB;;AAEA;CACC,oBAAoB;AACrB;;AAEA;CACC,YAAY;CACZ,aAAa;CACb,2BAA2B;AAC5B;;AAEA;CACC,8DAA8D;AAC/D;;AAEA;CACC,kEAAkE;AACnE;;AAEA;CACC,kCAAkC;AACnC;;AAEA;CACC,oCAAoC;AACrC;;AAEA;CACC,kCAAkC;AACnC;;AAEA;CACC,sCAAsC;AACvC;;AAEA;CACC,kCAAkC;AACnC;;AAEA;CACC,aAAa;CACb,mBAAmB;CACnB,eAAe;CACf,mBAAmB;CACnB,eAAe;AAChB;;AAEA;CACC,gBAAgB;AACjB;;AAEA;CACC;EACC,aAAa;CACd;;CAEA;EACC,wBAAwB;CACzB;;CAEA;EACC,iBAAiB;CAClB;AACD;;AAEA;CACC,aAAa;AACd;;AAEA;CACC,kBAAkB;AACnB;;AAEA;CACC,kBAAkB;AACnB;;AAEA;CACC,iBAAiB;AAClB;;AAEA;CACC,eAAe;AAChB;;AAGC;EACC,WAAW;CACZ;;AAGD;;;CAGC,eAAe;CACf,YAAY;AACb;;AAEA;;;CAGC,eAAe;CACf,YAAY;AACb;;AAEA;;;CAGC,oBAAoB;AACrB;;AAEA;CACC,eAAe;AAChB;;AAEA;CACC,YAAY;AACb;;AAEA;CACC,YAAY;AACb;;AAEA;CACC,WAAW;AACZ","sourcesContent":[".route-col_cell {\n\tposition: relative !important;\n\tpadding: 0 !important;\n\tmin-width: 60px;\n}\n\n.route-col_wrap {\n\tposition: absolute !important;\n\theight: 100%;\n\twidth: 100%;\n\tdisplay: flex;\n\tjustify-content: center;\n\talign-items: flex-start;\n}\n\n.route-col_wrap .icon {\n\tfont-size: 12px !important;\n}\n\n.route-col_val-num {\n\tmargin: auto 4px;\n}\n\n.route-col_icon-check {\n\tcolor: var(--mdt-color-brand-success);\n}\n\n.route-col_val-many > *:nth-child(2) {\n\tmargin-left: -4px !important;\n}\n\n.route-col_val-flag {\n\tcolor: var(--mdt-color-brand-warning);\n}\n\n.route-col_header-link {\n\twidth: 80px;\n}\n\n.route-col_header-link > div {\n\tdisplay: flex;\n\talign-items: center;\n}\n\n.route-col_header-link span {\n\tborder-bottom: 1px dashed var(--mdt-body-bg);\n\tcursor: pointer;\n}\n\n.route-col_header-link input {\n\tmargin-left: 8px;\n\tmargin-top: 0;\n}\n\n.route-col_inline-cell {\n\tpadding: 0 !important;\n\tposition: relative !important;\n}\n\n.route-col_inline-cell > div {\n\tposition: absolute;\n\tdisplay: flex;\n\theight: 100%;\n\twidth: 100%;\n\talign-items: center;\n}\n\n.route-col_inline-cell > div div {\n\tmargin: 0 !important;\n}\n\n.route-col_inline-cell > div input {\n\tborder: none;\n\toutline: none;\n\tbox-shadow: none !important;\n}\n\n.route-row_incorrect_freq {\n\tbackground-color: var(--mdt-gray-elements-bg-color) !important;\n}\n\n.route-row_incorrect_freq td {\n\tborder-color: var(--mdt-common-components-border-color) !important;\n}\n\n.route-row_incorrect_freq input {\n\tbackground: transparent !important;\n}\n\n.route-row_is-not-bound {\n\tbackground-color: #fffacf !important;\n}\n\n.route-row_is-not-bound input {\n\tbackground: transparent !important;\n}\n\n.route-row_is-not-active {\n\tbackground-color: #ff696973 !important;\n}\n\n.route-row_is-not-active input {\n\tbackground: transparent !important;\n}\n\n.route-management-total-time {\n\tdisplay: flex;\n\talign-items: center;\n\tpadding: 0 10px;\n\twhite-space: nowrap;\n\tcursor: pointer;\n}\n\n.route-management-total-time .icon {\n\tmargin-left: 5px;\n}\n\n@media (max-width: 1300px) {\n\t.route-management-page .page-block-head > h1 {\n\t\tdisplay: none;\n\t}\n\n\t.route-management-page .switch-buttons_label {\n\t\tdisplay: none !important;\n\t}\n\n\t.route-management-page .switch-buttons_buttons {\n\t\tmargin-left: 10px;\n\t}\n}\n\n.select-wrapper {\n\tdisplay: flex;\n}\n\n.select-wrapper .selected-info {\n\tmargin-right: 10px;\n}\n\n.select-wrapper .select-icon {\n\talign-self: center;\n}\n\n.select-wrapper .calendar {\n\tmargin-left: 10px;\n}\n\n.routes-time-transfer .common-control {\n\tmin-width: 50px;\n}\n\n.routes-copy-to {\n\t.grid {\n\t\twidth: 100%;\n\t}\n}\n\n.page-header-controls .routes-cycle-picker,\n.page-header-controls .routes-position-picker,\n.page-header-controls .routes-time-transfer {\n\tmargin-top: 0px;\n\theight: auto;\n}\n\n.page-header-controls .routes-cycle-picker .picker-control,\n.page-header-controls .routes-position-picker .picker-control,\n.page-header-controls .routes-time-transfer .picker-control {\n\tmargin-top: 0px;\n\theight: auto;\n}\n\n.page-header-controls .routes-cycle-picker label,\n.page-header-controls .routes-position-picker label,\n.page-header-controls .routes-time-transfer label {\n\tdisplay: inline-flex;\n}\n\n.page-header-controls .route-management-total-time .icon {\n\tfont-size: 15px;\n}\n\n.page-header-controls .routes-cycle-picker label + div {\n\twidth: 180px;\n}\n\n.page-header-controls .routes-position-picker label + div {\n\twidth: 300px;\n}\n\n.page-header-controls .routes-time-transfer label + div {\n\twidth: 60px;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 21:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TotalTimeControl = void 0;
const mdt_client_1 = __webpack_require__(305);
const Formatters_1 = __webpack_require__(942);
class TotalTimeControl {
    constructor(ctrl) {
        this.ctrl = ctrl;
        this.$view = () => {
            let ctrl = this.ctrl;
            let routePointsManager = ctrl.routePointsManager;
            if (!routePointsManager)
                return;
            if (!ctrl.route || !ctrl.position || !ctrl.cycle)
                return "";
            let weekData = ctrl.getCurrentWeekData();
            let fullResult = {
                cycle: routePointsManager.getTotalTimeInPeriod(ctrl.route, ctrl.cycle.DateBegin, ctrl.cycle.DateEnd),
                week: weekData && weekData.length
                    ? routePointsManager.getTotalTimeInPeriod(ctrl.route, weekData[0], weekData[weekData.length - 1])
                    : null,
                day: ctrl.currentDay ? routePointsManager.getTotalTime(ctrl.route, ctrl.currentDay) : null
            };
            let title = mdt_client_1.Utils.getText("Total time") + "\n" + this.formatTotalTimeData("Cycle", fullResult.cycle);
            if (fullResult.week)
                title += "\n" + this.formatTotalTimeData("Week", fullResult.week);
            if (fullResult.day)
                title += "\n" + this.formatTotalTimeData("Day", fullResult.day);
            let type = "cycle";
            let value = this.formatLabelValue(fullResult.cycle);
            if (this.ctrl.currentDay) {
                type = "day";
                value = this.formatLabelValue(fullResult.day);
            }
            else if (this.ctrl.currentWeek != null) {
                type = "week";
                value = this.formatLabelValue(fullResult.week);
            }
            let label = `${mdt_client_1.Utils.getText("Time")} (${mdt_client_1.Utils.getText(type)})`;
            return (0, mdt_client_1.m)(".route-management-total-time", {
                title: title
            }, label, ": ", value, mdt_client_1.legacy.ui.el.icon("question-circle"));
        };
    }
    formatValues(data) {
        let result = {};
        Object.keys(data).forEach(k => {
            result[k] = (0, Formatters_1.formatDuration)(data[k] * 60000) || "0";
        });
        return result;
    }
    formatLabelValue(data) {
        let x = this.formatValues(data);
        return `${x.timeAll} (${mdt_client_1.Utils.getText("transfer")} - ${x.timeTransfer})`;
    }
    formatTotalTimeData(title, x) {
        let d = this.formatValues(x);
        return `${mdt_client_1.Utils.getText(title)}: ${d.timeAll} (${mdt_client_1.Utils.getText("visits")} - ${d.timeVisit}, ${mdt_client_1.Utils.getText("transfer")} - ${d.timeTransfer})`;
    }
}
exports.TotalTimeControl = TotalTimeControl;


/***/ }),

/***/ 40:
/***/ ((module) => {



var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ 56:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ 72:
/***/ ((module) => {



var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ 113:
/***/ ((module) => {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ 133:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotActiveRowTransformer = void 0;
const mdt_client_1 = __webpack_require__(305);
class NotActiveRowTransformer {
    constructor(routePageCtrl) {
        this.routePageCtrl = routePageCtrl;
    }
    $view(ctrl, ctx) {
        let id = ctx.row.$id;
        if (!ctx.row.$id)
            return;
        let isNotActive = ctrl.routePageCtrl.isNotActive(id);
        if (isNotActive)
            mdt_client_1.legacy.ui.m.addClass(ctx.tr, "route-row_is-not-active");
    }
}
exports.NotActiveRowTransformer = NotActiveRowTransformer;


/***/ }),

/***/ 135:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shortMonthNames = exports.shortDayNames = void 0;
exports.getDaysArray = getDaysArray;
exports.getWeeksData = getWeeksData;
exports.compareDates = compareDates;
exports.romanize = romanize;
exports.getTimeValues = getTimeValues;
exports.uniqArray = uniqArray;
exports.isDateValid = isDateValid;
exports.pad = pad;
exports.toISO8601DateString = toISO8601DateString;
exports.shortDayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
exports.shortMonthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sept", "Oct", "Nov", "Dec"];
function getDaysArray(start, end) {
    const date = new Date(start.getTime());
    const arr = [];
    while (date <= end) {
        arr.push(new Date(date.getTime()));
        date.setDate(date.getDate() + 1);
    }
    return arr;
}
function getWeeksData(start, end, lastWeekDayIndex = 0) {
    let idx = 0;
    const result = [[]];
    const dates = getDaysArray(start, end);
    dates.forEach((date, i) => {
        result[idx].push(date);
        if (date.getDay() == lastWeekDayIndex && i < dates.length - 1) {
            idx++;
            result[idx] = [];
        }
    });
    return result;
}
function compareDates(resDate, valueDate) {
    if (!resDate || !valueDate)
        return false;
    const resultDate = new Date(resDate);
    const dateVal = new Date(valueDate);
    return resultDate.getFullYear() === dateVal.getFullYear() &&
        resultDate.getMonth() === dateVal.getMonth() &&
        resultDate.getDate() === dateVal.getDate();
}
function romanize(num) {
    const lookup = {
        M: 1000,
        CM: 900,
        D: 500,
        CD: 400,
        C: 100,
        XC: 90,
        L: 50,
        XL: 40,
        X: 10,
        IX: 9,
        V: 5,
        IV: 4,
        I: 1
    };
    let roman = "", i;
    for (i in lookup) {
        while (num >= lookup[i]) {
            roman += i;
            num -= lookup[i];
        }
    }
    return roman;
}
function getTimeValues(duration) {
    return {
        seconds: parseInt(((duration / 1000) % 60)),
        minutes: parseInt(((duration / (1000 * 60)) % 60)),
        hours: parseInt(((duration / (1000 * 60 * 60)) % 24)),
        days: parseInt((duration / (1000 * 60 * 60 * 24)))
    };
}
function onlyUnique(value, index, self) {
    return self.indexOf(value) === index;
}
function uniqArray(arr) {
    if (arr == null)
        return arr;
    return arr.filter(onlyUnique);
}
function isDateValid(date) {
    return date && date.getTime && !isNaN(date.getTime());
}
function pad(n) {
    return `${n < 10 ? "0" + n.toString() : n}`;
}
function toISO8601DateString(date) {
    return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;
}


/***/ }),

/***/ 180:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FrequencyRowTransformer = void 0;
const mdt_client_1 = __webpack_require__(305);
class FrequencyRowTransformer {
    constructor(routePageCtrl) {
        this.routePageCtrl = routePageCtrl;
    }
    $view(ctrl, ctx) {
        let id = ctx.row.$id;
        if (!ctx.row.$id)
            return;
        let count = ctrl.routePageCtrl.routePointsManager.getPointsByOutlet(id)
            .length;
        if (!count)
            mdt_client_1.legacy.ui.m.addClass(ctx.tr, "route-row_incorrect_freq");
    }
}
exports.FrequencyRowTransformer = FrequencyRowTransformer;


/***/ }),

/***/ 198:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RouteManagementCtrl = void 0;
const RouteManager_1 = __webpack_require__(546);
const mdt_client_1 = __webpack_require__(305);
const RoutePointsManager_1 = __webpack_require__(292);
const RouteRowCellTransformer_1 = __webpack_require__(571);
const FrequencyRowTransformer_1 = __webpack_require__(180);
const NotBoundRowTransformer_1 = __webpack_require__(857);
const NotActiveRowTransformer_1 = __webpack_require__(133);
const CopyRouteControl_1 = __webpack_require__(853);
const TotalTimeControl_1 = __webpack_require__(21);
const RouteColumns_1 = __webpack_require__(757);
const Formatters_1 = __webpack_require__(942);
const utils_1 = __webpack_require__(135);
class RouteManagementCtrl {
    static namedFilter() {
        return {
            code: "mapping",
            tooltip: mdt_client_1.Utils.getText("formControl:Filter"),
            filters: [
                { title: mdt_client_1.Utils.getText("All outlets"), selected: true, filter: mdt_client_1.Filter.ne("ID_Cycle", null) },
                { title: mdt_client_1.Utils.getText("Outlets in the route"), filter: mdt_client_1.Filter.eq("FlagOutletInRoute", true) },
                {
                    title: mdt_client_1.Utils.getText("Outlets in the route with observed frequency"),
                    filter: mdt_client_1.Filter.and(mdt_client_1.Filter.eq("FlagOutletInRoute", true), mdt_client_1.Filter.eq("FlagObservedFrequency", true))
                },
                {
                    title: mdt_client_1.Utils.getText("Outlets in the route without observed frequency"),
                    filter: mdt_client_1.Filter.and(mdt_client_1.Filter.eq("FlagOutletInRoute", true), mdt_client_1.Filter.eq("FlagObservedFrequency", false))
                },
                { title: mdt_client_1.Utils.getText("Outlets not in the route"), filter: mdt_client_1.Filter.eq("FlagOutletInRoute", false) }
            ]
        };
    }
    constructor(options) {
        this.options = options;
        //model
        this.positionIdProp = mdt_client_1.legacy.utils.prop();
        this.cycleIdProp = mdt_client_1.legacy.utils.prop();
        this.routeTimeTransfer = mdt_client_1.legacy.utils.prop();
        this.outletData = [];
        this.currentWeek = null;
        this.currentDay = null;
        this.selected = {
            days: [],
            weeks: []
        };
        this.initContainer = (container) => {
            container.cssClasses = "route-management-page";
            let routeTable = mdt_client_1.legacy.SchemaManagerInstance.get(RouteManager_1.RouteManager.SCHEMA.route.code);
            let cycleCode = "Cycle";
            let positionCode = "Position";
            let timeCode = "Time";
            let saveRouteTimeout;
            let headerControls = new mdt_client_1.legacy.PageHeaderControls({
                controlsSettings: [
                    {
                        code: cycleCode,
                        prop: this.cycleIdProp,
                        field: Object.assign(Object.assign({}, mdt_client_1.legacy.SchemaManagerInstance.field(routeTable, RouteManager_1.RouteManager.SCHEMA.route.fields.idCycle)), { code: RouteManager_1.RouteManager.SCHEMA.route.fields.idCycle, nullable: true }),
                        options: Object.assign({ hintSelect: ["DateBegin", "DateEnd"], css: "routes-cycle-picker" }, this.options.cyclePicker)
                    },
                    {
                        code: positionCode,
                        prop: this.positionIdProp,
                        field: Object.assign(Object.assign({}, mdt_client_1.legacy.SchemaManagerInstance.field(routeTable, RouteManager_1.RouteManager.SCHEMA.route.fields.idPosition)), { code: RouteManager_1.RouteManager.SCHEMA.route.fields.idPosition, nullable: true }),
                        options: Object.assign({ css: "routes-position-picker" }, this.options.positionPicker)
                    },
                    {
                        code: timeCode,
                        prop: this.routeTimeTransfer,
                        field: Object.assign(Object.assign({}, mdt_client_1.legacy.SchemaManagerInstance.field(routeTable, RouteManager_1.RouteManager.SCHEMA.route.fields.timeTransfer)), { code: "Time", nullable: true }),
                        options: {
                            visible: () => !!this.route,
                            enabled: () => this.route && !this.isReadonly(),
                            placeholder: RouteManager_1.RouteManager.Settings.TimeTransfer,
                            customText: () => this.routeTimeTransfer(),
                            css: "routes-time-transfer"
                        }
                    }
                ]
            }, {
                onchange: (code, v, record, r, data = {}) => {
                    let { $fetchDisplayValue, $autopick } = data;
                    if (code == cycleCode) {
                        if (record && record.$fake) {
                            record = null;
                            this.cycleIdProp(null);
                        }
                        this.setCycle(record, $fetchDisplayValue, $autopick);
                    }
                    else if (code == positionCode) {
                        if (record && record.$fake) {
                            record = null;
                            this.positionIdProp(null);
                        }
                        this.setPosition(record, $fetchDisplayValue, $autopick);
                    }
                    else if (code == timeCode) {
                        clearTimeout(saveRouteTimeout);
                        saveRouteTimeout = setTimeout(() => {
                            if (v < 0 || isNaN(v)) {
                                mdt_client_1.Ui.showModal(mdt_client_1.Utils.getText("Invalid value. Time must be a number greater than or equal to zero"), {
                                    type: "warning",
                                    title: "Error"
                                });
                                return;
                            }
                            this.routeManager
                                .saveRoute({
                                ID: this.route.ID,
                                TimeTransfer: v !== null && v !== void 0 ? v : RouteManager_1.RouteManager.Settings.TimeTransfer
                            })
                                .then(() => {
                                this.route.TimeTransfer = v;
                                mdt_client_1.legacy.ui.show.success("Route time transfer updated!", "");
                            });
                        }, RouteManager_1.RouteManager.Settings.TimeTransferUpdateDelay);
                    }
                }
            });
            container.zones.header.push(headerControls);
            container.zones.header.push(new TotalTimeControl_1.TotalTimeControl(this));
        };
        options.cyclePicker.picked = () => this.updateRouteTable();
        this.updateContent(true);
        this.routeManager = new RouteManager_1.RouteManager();
        this.routeManager.fetchCyclePeriods().then((periods) => (this.cyclePeriods = periods.records));
        // Parse URL Params
        let { cycleId, positionId } = RouteManager_1.RouteManager.getUrlParams();
        this.cycleIdProp(cycleId);
        this.positionIdProp(positionId);
    }
    updateRouteTable() {
        this.selected.weeks = [];
        this.selected.days = [];
        if (this.route)
            this.refreshRoutePoints(this.route.ID);
    }
    setPosition(position, $initial, $autopick) {
        this.position = position;
        this.updateContent($initial, $autopick);
    }
    setCycle(cycle, $initial, $autopick) {
        this.cycle = cycle;
        this.currentWeek = null;
        this.currentDay = null;
        this.weeksData =
            this.cycle && this.cycle.DateBegin && this.cycle.DateEnd
                ? (0, utils_1.getWeeksData)(this.cycle.DateBegin, this.cycle.DateEnd)
                : null;
        this.updateContent($initial, $autopick);
    }
    setWeekIndex(v) {
        this.currentWeek = v;
        this.currentDay = null;
        this.list.relayout();
    }
    setDay(date, resetSorting) {
        this.currentDay = date;
        resetSorting && this.list.paging && this.list.paging.sorting && this.list.paging.sorting.clear();
        this.list.relayout();
    }
    updateRouteState(replace) {
        let args = {};
        if (this.cycle)
            args[RouteManager_1.RouteManager.Settings.RouteURLParams.Cycle] = this.cycle.ID;
        if (this.position)
            args[RouteManager_1.RouteManager.Settings.RouteURLParams.Position] = this.position.ID;
        RouteManager_1.RouteManager.setUrlParams(args, replace);
    }
    updateContent($initial, $autopick) {
        if (!$initial && !$autopick)
            this.updateRouteState($autopick);
        if (!this.position || !this.cycle) {
            this.content = mdt_client_1.legacy.CenteredMessageCtrl(`${mdt_client_1.Utils.getText("Please select cycle and position")}!`);
            return;
        }
        this.content = mdt_client_1.legacy.CenteredMessageCtrl(`${mdt_client_1.Utils.getText("Loading...")}`);
        this.routeManager.loadRouteData(this.cycle, this.position.ID).then((route) => {
            this.route = route;
            this.routeTimeTransfer(this.route.TimeTransfer);
            this.refreshRoutePoints(this.route.ID).then(() => {
                this.initList();
            });
        });
    }
    refreshRoutePoints(ID_Route) {
        return this.routeManager.getRoutePoints(ID_Route).then((r) => {
            this.routePointsManager = new RoutePointsManager_1.RoutePointsManager(r, ID_Route);
            return r;
        });
    }
    initList() {
        let outletTable = mdt_client_1.Schema.getObject(RouteManager_1.RouteManager.SCHEMA.outlet.code);
        let routeTable = mdt_client_1.legacy.SchemaManagerInstance.get(RouteManager_1.RouteManager.SCHEMA.route.code);
        let defauldField = outletTable.getDefaultField();
        let s = RouteManager_1.RouteManager.SCHEMA;
        this.list = mdt_client_1.legacy.components.simpleList(mdt_client_1.legacy.SchemaManagerInstance.get(RouteManager_1.RouteManager.SCHEMA.outlet.code), mdt_client_1.legacy.utils.combine({
            root: true,
            events: {
                inited: [(list) => this.initColumns(list)],
                query: [
                    (query) => {
                        query.select = (0, utils_1.uniqArray)(query.select.concat("FlagNotBound", "Frequency", "FlagNotActive"));
                    }
                ],
                fetched: [
                    (x, query) => {
                        if (query.skip == 0) {
                            this.outletData = [];
                        }
                        if (!x.records.length)
                            return;
                        x.records.forEach((x) => {
                            x.ID = x.ID_Outlet;
                            x.$id = x.ID;
                        });
                        this.outletData = this.outletData.concat(x.records);
                    }
                ]
            },
            transformers: {
                cell: [new RouteRowCellTransformer_1.RouteRowCellTransformer(this)],
                row: [
                    new FrequencyRowTransformer_1.FrequencyRowTransformer(this),
                    new NotBoundRowTransformer_1.NotBoundRowTransformer(this),
                    new NotActiveRowTransformer_1.NotActiveRowTransformer(this)
                ]
            },
            disableRowCache: true,
            layout: {
                id: 1,
                columns: this.options.listColumns
                    ? this.options.listColumns
                    : [
                        {
                            title: outletTable.getTitle(),
                            code: defauldField.getCode()
                        }
                    ]
            },
            datasource: {
                fetch: (query, table) => {
                    const queryWithParams = this.setQueryParams(query);
                    return mdt_client_1.Api.fetchFunction(table.code, queryWithParams.params, queryWithParams);
                }
            }
        }, this.options.listOptions), mdt_client_1.legacy.utils.combine({
            toolbar: {
                buttons: [
                    new mdt_client_1.legacy.modules.status.StatusButton(routeTable, this.route, {
                        onStatusChange: () => {
                            this.routeManager.getRoute(this.cycle.ID, this.position.ID).then((x) => {
                                this.route = x;
                            });
                        }
                    }),
                    {
                        wrapClass: "toolbar-flex-content",
                        control: this.weeksSwitch(),
                        visible: () => this.isWeekSwitchVisible()
                    },
                    {
                        wrapClass: "toolbar-flex-content",
                        control: this.daysSwitch(),
                        visible: () => this.isDaysSwitchVisible()
                    },
                    {
                        title: "routes:Copy",
                        icon: "copy",
                        enabled: () => this.isEnabledCopyButton(),
                        order: mdt_client_1.legacy.list.ToolbarCtrl.ORDER.LATEST + 100,
                        command: () => {
                            let copyRouteControl = new CopyRouteControl_1.CopyRouteControl(this.cycle.ID, [this.position.ID], { [this.position.ID]: this.route }, this.selected.days.length
                                ? this.selected.days.map((x) => {
                                    return {
                                        From: {
                                            date: x.date,
                                            dateIndexInCycle: x.dateIndex,
                                            cycleWeekIndex: x.weekIndex
                                        },
                                        To: {}
                                    };
                                })
                                : this.selected.weeks.map((x) => {
                                    return {
                                        From: {
                                            week: x.weekData,
                                            cycleWeekIndex: x.weekIndex
                                        },
                                        To: {}
                                    };
                                }), () => this.updateRouteTable(), this.cyclePeriods);
                            mdt_client_1.Ui.showModal(copyRouteControl, {
                                onClose: () => this.list.refresh()
                            });
                        }
                    },
                    {
                        title: "Clear",
                        icon: "eraser",
                        enabled: () => this.isEnabledClearButton(),
                        order: mdt_client_1.legacy.list.ToolbarCtrl.ORDER.LATEST + 100,
                        command: () => {
                            const routesForClear = this.getActiveSelectedRoutes();
                            mdt_client_1.legacy.confirmModal(`Вы действительно хотите очистить записи в выбранных колонках? Это отменит маршрут на выбранные дни.`, mdt_client_1.Utils.getText("serverMessageType:Confirmation"), (btn) => {
                                btn.command = () => this.routePointsManager.deleteRecords(routesForClear);
                                btn.title = "Clear";
                                btn.icon = "eraser";
                                return btn;
                            });
                        }
                    }
                ]
            },
            inMemoryNamedFilter: { groups: [RouteManagementCtrl.namedFilter()] },
            legend: {
                items: [
                    {
                        title: mdt_client_1.Utils.getText("No visits"),
                        cssClass: "route-row_incorrect_freq"
                    },
                    {
                        title: mdt_client_1.Utils.getText("Outlet not bound"),
                        cssClass: "route-row_is-not-bound"
                    },
                    {
                        title: mdt_client_1.Utils.getText("Outlet is not active"),
                        cssClass: "route-row_is-not-active"
                    }
                ]
            },
            designer: false,
            export: {
                prepareQuery: (query) => {
                    return this.setQueryParams(query);
                }
            }
        }, this.options.extConfig));
        this.content = this.list;
    }
    setQueryParams(query) {
        const currentDay = query.sorting.length > 0 ? null : this.currentDay;
        query.params = {
            ID_Cycle: this.cycle.ID,
            ID_em_Position: this.position.ID,
            Date: currentDay
        };
        return query;
    }
    initColumns(list) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        list.columns().push(...this.createWeekColumns());
        if ((_b = (_a = this.options.timeColumn) === null || _a === void 0 ? void 0 : _a.visible) !== null && _b !== void 0 ? _b : true) {
            list.columns().splice((_d = (_c = this.options.timeColumn) === null || _c === void 0 ? void 0 : _c.position) !== null && _d !== void 0 ? _d : Number.MAX_VALUE, 0, (0, RouteColumns_1.createTimeColumn)(this));
        }
        if ((_f = (_e = this.options.frequencyColumn) === null || _e === void 0 ? void 0 : _e.visible) !== null && _f !== void 0 ? _f : true) {
            list.columns().splice((_h = (_g = this.options.frequencyColumn) === null || _g === void 0 ? void 0 : _g.position) !== null && _h !== void 0 ? _h : Number.MAX_VALUE, 0, {
                title: mdt_client_1.Utils.getText("Frequency"),
                $routeColumnType: RouteColumns_1.SFRouteColumnType.frequency,
                control: new mdt_client_1.legacy.list.CustomColumnCtrl({
                    value: (ctx) => {
                        let id = ctx.row.ID;
                        if (!id)
                            return;
                        let count = this.routePointsManager.getPointsByOutlet(id).length;
                        let idOutletCode = RouteManager_1.RouteManager.SCHEMA.outletData.fields.idOutlet;
                        let x = this.outletData.find((d) => d[idOutletCode] == id);
                        let freq = x && x.Frequency;
                        return (0, mdt_client_1.m)(`${count != freq ? ".text-danger" : ""}`, `${count}/${freq}`);
                    }
                })
            });
        }
    }
    createWeekColumns() {
        let listColumns = [];
        if (!this.weeksData)
            return listColumns;
        if (this.currentWeek == null) {
            listColumns = listColumns.concat(this.weeksData.map((weekData, idx) => {
                return (0, RouteColumns_1.createWeekColumn)(idx, weekData, this);
            }));
        }
        else if (this.currentWeek != null && this.currentDay == null) {
            listColumns = listColumns.concat(this.getCurrentWeekData().map((date) => {
                return (0, RouteColumns_1.createDayColumn)(date, this.getDateIndex(date), this.getWeekIndex(date), this);
            }));
        }
        else if (this.currentWeek != null && this.currentDay != null) {
            let date = this.getCurrentDay();
            listColumns.push((0, RouteColumns_1.createDayColumn)(date, this.getDateIndex(date), this.getWeekIndex(date), this));
            listColumns.push((0, RouteColumns_1.createTimeVisitColumn)(this));
        }
        return listColumns;
    }
    getVisitTime(routePoint) {
        return routePoint.TimeVisit || this.route.TimeVisit || RouteManager_1.RouteManager.Settings.TimeVisit;
    }
    isWeekSwitchVisible() {
        return !!this.weeksData;
    }
    weeksSwitch() {
        return new mdt_client_1.legacy.list.SwitchButtons({
            label: `${mdt_client_1.Utils.getText("Week")}:`,
            items: () => {
                return this.weeksData
                    .map((weeksData, idx) => {
                    return {
                        key: idx,
                        title: (0, Formatters_1.formatWeekTitle)(idx),
                        description: (0, Formatters_1.formatWeekDates)(weeksData),
                        selected: this.currentWeek == idx
                    };
                })
                    .concat({
                    key: null,
                    title: `${mdt_client_1.Utils.getText("All")}`,
                    selected: this.currentWeek == null
                });
            },
            onSelect: (item) => {
                this.setWeekIndex(item.key);
            }
        });
    }
    isDaysSwitchVisible() {
        return !!this.weeksData && this.currentWeek != null;
    }
    daysSwitch() {
        return new mdt_client_1.legacy.list.SwitchButtons({
            label: `${mdt_client_1.Utils.getText("Day")}:`,
            items: () => {
                return this.getCurrentWeekData()
                    .map((date) => {
                    let attrs = {};
                    let isWorkday = this.routeManager.isWorkday(date);
                    if (!isWorkday)
                        attrs.title = mdt_client_1.Utils.getText("Holiday");
                    return {
                        key: date.getTime(),
                        $data: date,
                        title: mdt_client_1.Utils.getText(utils_1.shortDayNames[date.getDay()]),
                        description: (0, Formatters_1.formatDay)(date),
                        selected: (0, utils_1.compareDates)(this.currentDay, date),
                        cssClass: isWorkday ? null : "text-danger",
                        attrs
                    };
                })
                    .concat({
                    key: null,
                    title: `${mdt_client_1.Utils.getText("All")}`,
                    selected: this.currentDay == null
                });
            },
            onSelect: (item) => {
                this.setDay(item.$data);
            }
        });
    }
    getCurrentWeekData() {
        return this.currentWeek == null ? null : this.weeksData[this.currentWeek];
    }
    getCurrentDay() {
        return this.currentWeek != null && this.currentDay != null
            ? this.getCurrentWeekData().find((date) => (0, utils_1.compareDates)(date, this.currentDay))
            : null;
    }
    isReadonly() {
        return this.route ? this.routeManager.isReadonly(this.route) : true;
    }
    selectWeek(weekData, index) {
        this.selected.days = [];
        this.isWeekSelected(index)
            ? this.selected.weeks = this.selected.weeks.filter(({ weekIndex }) => weekIndex !== index)
            : this.selected.weeks.push({ weekData: weekData, weekIndex: index });
    }
    selectDay(date, weekIndex, dateIndex) {
        this.selected.weeks = [];
        this.isDaySelected(date)
            ? this.selected.days = this.selected.days.filter(({ date: selectedDate }) => selectedDate !== date)
            : this.selected.days.push({ date, weekIndex: weekIndex, dateIndex });
    }
    isWeekSelected(index) {
        return this.selected.weeks.find((x) => x.weekIndex === index) && true;
    }
    isDaySelected(date) {
        return this.selected.days.find((x) => x.date === date) && true;
    }
    isEnabledCopyButton() {
        return this.selected.days.length || this.selected.weeks.length;
    }
    isEnabledClearButton() {
        return this.getActiveSelectedRoutes().length != 0 && !this.isReadonly();
    }
    getActiveSelectedRoutes() {
        const routesForClear = [];
        if (this.selected.days.length) {
            this.selected.days.map((day) => {
                routesForClear.push(...this.routePointsManager.getPoints(day.date, true));
            });
        }
        else {
            this.selected.weeks.map((week) => {
                week.weekData.forEach((day) => {
                    routesForClear.push(...this.routePointsManager.getPoints(day, true));
                });
            });
        }
        return routesForClear;
    }
    getWeekIndex(date) {
        return this.weeksData.findIndex((x) => x.includes(date));
    }
    getDateIndex(date) {
        var timeDiff = Math.abs(date.getTime() - this.cycle.DateBegin.getTime());
        var diffDays = Math.ceil(timeDiff / (1000 * 3600 * 24));
        return diffDays;
    }
    isNotBound(ID_Outlet) {
        var outlet = this.outletData.find((r) => r.ID_Outlet == ID_Outlet);
        return outlet && outlet.FlagNotBound;
    }
    isNotActive(ID_Outlet) {
        var outlet = this.outletData.find((r) => r.ID_Outlet == ID_Outlet);
        return outlet && outlet.FlagNotActive;
    }
}
exports.RouteManagementCtrl = RouteManagementCtrl;


/***/ }),

/***/ 233:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RouteApprovalPage = void 0;
const mdt_client_1 = __webpack_require__(305);
const RouteApprovalCtrl_1 = __webpack_require__(739);
class RouteApprovalPage extends RouteApprovalCtrl_1.RouteApprovalCtrl {
    constructor(node) {
        let options = {};
        if (node.controlTemplate) {
            try {
                options = JSON.parse(node.controlTemplate);
            }
            catch (e) {
                console.error("Can't parse node control template!", e);
            }
        }
        options.cyclePicker = Object.assign({ autopick: {
                sorting: [{ path: "DateBegin", asc: true }],
                filter: mdt_client_1.Filter.ge("DateBegin", new Date())
            }, searchOperation: "contains" }, options.cyclePicker);
        options.positionPicker = Object.assign({ autopick: {
                sorting: [{ path: "ID", asc: false }],
                filter: {
                    op: "eq",
                    p1: "EmployeeHistory/ID_Employee/ID_mdt_Principal",
                    p2: "ID_CURRENT_USER"
                }
            }, searchOperation: "contains" }, options.positionPicker);
        super(options);
    }
}
exports.RouteApprovalPage = RouteApprovalPage;


/***/ }),

/***/ 286:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RouteWeekColumnTemplates = exports.RouteWeekColumn = void 0;
const mdt_client_1 = __webpack_require__(305);
class RouteWeekColumn {
    constructor(options) {
        this.options = options;
    }
}
exports.RouteWeekColumn = RouteWeekColumn;
const iconCheck = () => (0, mdt_client_1.m)("span.route-col_icon-check", mdt_client_1.legacy.ui.el.icon("check"));
exports.RouteWeekColumnTemplates = {
    one: () => (0, mdt_client_1.m)(".route-col_val-one", iconCheck()),
    many: (title) => (0, mdt_client_1.m)(`.route-col_val-many[title="${title}"]`, iconCheck(), iconCheck()),
    flag: () => (0, mdt_client_1.m)(".route-col_val-flag", mdt_client_1.legacy.ui.el.icon("flag")),
    day: (num) => (0, mdt_client_1.m)("", iconCheck(), (0, mdt_client_1.m)("span.route-col_val-num", `${num}`))
};
mdt_client_1.legacy.viewer(RouteWeekColumn, (ctrl, ctx) => {
    if (ctx.isHead) {
        mdt_client_1.legacy.ui.m.addClass(ctx.th, "route-col_header-link");
        return [
            (0, mdt_client_1.m)("span", {
                onclick: () => ctrl.options.onHeadClick && ctrl.options.onHeadClick(ctx)
            }, ctx.headerText),
            (0, mdt_client_1.m)("input[type=checkbox]", {
                onclick: (e) => {
                    ctrl.options.onHeadCheckboxClick(ctx);
                    e.stopPropagation();
                },
                checked: ctrl.options.isHeadCheckboxChecked()
            })
        ];
    }
    mdt_client_1.legacy.ui.m.addClass(ctx.td, "route-col_cell");
    return (0, mdt_client_1.m)(".route-col_wrap", {
        onclick: () => ctrl.options.active && ctrl.options.active() ? ctrl.options.onclick && ctrl.options.onclick(ctx) : mdt_client_1.legacy.utils.noop()
    }, ctrl.options.value(ctx));
});


/***/ }),

/***/ 292:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoutePointsManager = void 0;
const RouteManager_1 = __webpack_require__(546);
const mdt_client_1 = __webpack_require__(305);
const utils_1 = __webpack_require__(135);
class RoutePointsManager {
    constructor(original, ID_Route) {
        this.original = original;
        this.ID_Route = ID_Route;
        this.routeManager = new RouteManager_1.RouteManager();
        this.state = {
            pending: mdt_client_1.legacy.utils.prop(false)
        };
        this.init();
        this.rm = mdt_client_1.legacy.RecordManagerInstance;
    }
    init() {
        this.data = mdt_client_1.legacy.utils.clone(this.original);
    }
    toggle(outletData, date) {
        let ID_Outlet = outletData.ID_Outlet;
        let rec = this.data.find((r) => r.ID_Outlet == ID_Outlet && (0, utils_1.compareDates)(r.Date, date) && !this.rm.isDestroyed(r));
        if (rec) {
            this.delete(rec);
        }
        else {
            this.addAvailable(outletData) && this.add(ID_Outlet, date);
        }
    }
    addAvailable(outletData) {
        return !outletData.FlagNotBound;
    }
    add(ID_Outlet, date) {
        let curRecs = this.getOrderedPoints(date);
        let f = RouteManager_1.RouteManager.SCHEMA.routePoint.fields;
        let newRecord = this.rm.newRecord({
            [f.idOutlet]: ID_Outlet,
            [f.date]: date,
            [f.idRoute]: this.ID_Route,
            [f.sortOrder]: curRecs.length ? curRecs[curRecs.length - 1].SortOrder + 1 : 1,
            $table: mdt_client_1.legacy.SchemaManagerInstance.get(RouteManager_1.RouteManager.SCHEMA.routePoint.code)
        });
        this.data.push(newRecord);
        this.state.pending(true);
        this.routeManager.saveRoutePoints(this.getOrderedPoints(date)).then((x) => {
            this.state.pending(false);
            let id = mdt_client_1.legacy.ServerMessageHelper.getInsertedId(x);
            newRecord.$id = newRecord.ID = id;
        });
    }
    delete(record) {
        this.deleteRecords([record]);
    }
    deleteRecords(records = []) {
        if (records.length == 0)
            return;
        const updatedRecords = [];
        records.forEach((route) => {
            this.rm.destroy(route);
            this.getOrderedPoints(route.Date).forEach((r, idx) => {
                r.SortOrder = idx + 1;
                if (!records.includes(r)) {
                    updatedRecords.push(r);
                }
            });
        });
        const meta = {
            messageAction: {
                actions: [{
                        code: "DmFlagConfirm",
                        value: "true"
                    }]
            }
        };
        this.state.pending(true);
        this.routeManager.saveRoutePoints([...records, ...updatedRecords], meta).then(() => {
            this.data = this.data.filter(item => !records.includes(item));
            this.state.pending(false);
        });
    }
    getData(activeOnly = true) {
        return activeOnly ? this.data.filter((r) => !this.rm.isDestroyed(r)) : this.data;
    }
    getPoint(ID_Outlet, date) {
        return this.getData().find((r) => {
            return r.ID_Outlet == ID_Outlet && (0, utils_1.compareDates)(r.Date, date);
        });
    }
    getPoints(date, activeOnly) {
        return this.getData(activeOnly).filter((r) => (0, utils_1.compareDates)(r.Date, date));
    }
    getPointsByOutlet(ID_Outlet) {
        return this.getData().filter((r) => r.ID_Outlet == ID_Outlet);
    }
    getOrderedPoints(date) {
        return this.getPoints(date).sort(this.rm.sort);
    }
    getTimeTransfer(route) {
        return route.TimeTransfer || 0;
    }
    getTimeVisit(routePoint, route) {
        return routePoint.TimeVisit || route.TimeVisit || 0;
    }
    getTotalTime(route, date) {
        let points = this.getPoints(date) || [];
        let timeTransfer = points.length ? (points.length - 1) * this.getTimeTransfer(route) : 0;
        let timeVisit = points.reduce((acc, r) => acc + this.getTimeVisit(r, route), 0);
        return {
            timeAll: timeVisit + timeTransfer,
            timeTransfer,
            timeVisit
        };
    }
    getTotalTimeInPeriod(route, dateBegin, dateEnd) {
        let result = {
            timeAll: 0,
            timeTransfer: 0,
            timeVisit: 0
        };
        (0, utils_1.getDaysArray)(dateBegin, dateEnd).forEach((date) => {
            let x = this.getTotalTime(route, date);
            result.timeAll += x.timeAll;
            result.timeTransfer += x.timeTransfer;
            result.timeVisit += x.timeVisit;
        });
        return result;
    }
}
exports.RoutePointsManager = RoutePointsManager;


/***/ }),

/***/ 305:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerModule = exports.legacy = exports.modules = exports.App = exports.Schema = exports.UiComponents = exports.ModuleRegistry = exports.RecordManager = exports.CommandManager = exports.Page = exports.Auth = exports.Filter = exports.m = exports.Api = exports.Ui = exports.Utils = exports.mUtils = exports.FieldControl = exports.ControlManager = exports.Form = exports.FormService = exports.List = exports.ListService = exports.SecurityManager = exports.Navigation = exports.MDT = void 0;
var package_json_1 = __importDefault(__webpack_require__(523));
exports.MDT = window.MDT;
exports.Navigation = exports.MDT.Navigation, exports.SecurityManager = exports.MDT.SecurityManager, exports.ListService = exports.MDT.ListService, exports.List = exports.MDT.List, exports.FormService = exports.MDT.FormService, exports.Form = exports.MDT.Form, exports.ControlManager = exports.MDT.ControlManager, exports.FieldControl = exports.MDT.FieldControl, exports.mUtils = exports.MDT.mUtils, exports.Utils = exports.MDT.Utils, exports.Ui = exports.MDT.Ui, exports.Api = exports.MDT.Api, exports.m = exports.MDT.m, exports.Filter = exports.MDT.Filter, exports.Auth = exports.MDT.Auth, exports.Page = exports.MDT.Page, exports.CommandManager = exports.MDT.CommandManager, exports.RecordManager = exports.MDT.RecordManager, exports.ModuleRegistry = exports.MDT.ModuleRegistry, exports.UiComponents = exports.MDT.UiComponents, exports.Schema = exports.MDT.Schema, exports.App = exports.MDT.App, exports.modules = exports.MDT.modules, exports.legacy = exports.MDT.legacy;
function registerModule(callback, context) {
    exports.MDT.registerModule(callback, {
        version: package_json_1.default.version,
        name: context === null || context === void 0 ? void 0 : context.name
    });
}
exports.registerModule = registerModule;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 314:
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ 354:
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ 523:
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"mdt-client","version":"31.2.0","description":"","main":"dist/index.js","types":"dist/index.d.ts","files":["/dist","/types"],"scripts":{"build":"tsc","types-update":"tsc --project tsconfig.facade-types.json","update":"tsc --project tsconfig.facade-types.json && tsc","pub-patch":"npm version patch && npm publish","pub-minor":"npm version minor && npm publish"},"repository":{"type":"git","url":"git@gitlab.ics-it.ru:mdtc/mdt-facade.git"},"author":"","license":"ISC","devDependencies":{"typescript":"^4.8.4"},"dependencies":{"@types/mithril":"^0.0.27"}}');

/***/ }),

/***/ 540:
/***/ ((module) => {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ 546:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RouteManager = void 0;
const mdt_client_1 = __webpack_require__(305);
const utils_1 = __webpack_require__(135);
class RouteManager {
    constructor() {
        this.holydays = [];
    }
    loadRouteData(cycle, ID_Position) {
        return mdt_client_1.m.sync([
            this.getRoute(cycle.ID, ID_Position),
            this.fetchStatuses(),
            this.fetchHolydays(cycle.DateBegin, cycle.DateEnd)
        ])
            .then(([route]) => route);
    }
    fetchCyclePeriods() {
        const date = new Date();
        date.setFullYear(date.getFullYear() - 3);
        return mdt_client_1.Api.fetch('rt.Week', {
            filter: mdt_client_1.Filter.ge('DateBegin', date),
            top: 500
        });
    }
    getRoute(ID_Cycle, ID_Position) {
        let deferred = mdt_client_1.m.deferred();
        this.fetchRoute(ID_Cycle, ID_Position).then(rec => {
            if (rec) {
                deferred.resolve(rec);
            }
            else {
                this.saveRoute({
                    ID_Cycle,
                    [RouteManager.SCHEMA.route.fields.idPosition]: ID_Position,
                    TimeTransfer: RouteManager.Settings.TimeTransfer,
                    TimeVisit: RouteManager.Settings.TimeVisit
                }).then(() => {
                    this.fetchRoute(ID_Cycle, ID_Position).then(x => {
                        if (!x)
                            throw new Error(`${mdt_client_1.Utils.getText(`Can't create route`)}!`);
                        mdt_client_1.legacy.ui.show.info(mdt_client_1.Utils.getText(`${mdt_client_1.Utils.getText(`New route created`)}!`), "");
                        deferred.resolve(x);
                    });
                });
            }
        });
        return deferred.promise;
    }
    fetchRoute(ID_Cycle, ID_Position) {
        return mdt_client_1.Api.fetch(RouteManager.SCHEMA.route.code, {
            filter: mdt_client_1.Filter.and(mdt_client_1.Filter.eq(RouteManager.SCHEMA.route.fields.idPosition, ID_Position), mdt_client_1.Filter.eq(RouteManager.SCHEMA.route.fields.idCycle, ID_Cycle))
        }).then(x => x && x.records && x.records[0]);
    }
    saveRoute(data) {
        return mdt_client_1.legacy.ApiServiceInstance.save(Object.assign({ $table: data.$table || RouteManager.SCHEMA.route.code }, data));
    }
    copyRoutesDataSource(options) {
        return mdt_client_1.legacy.ApiService.createCustomDatasource(RouteManager.SCHEMA.procedures.copy, options);
    }
    saveRoutePoints(data, meta) {
        return mdt_client_1.legacy.ApiServiceInstance.save(data, {}, {}, null, meta);
    }
    saveRoutePoint(point) {
        return mdt_client_1.legacy.ApiServiceInstance.save(point);
    }
    getRoutePoints(ID_Route) {
        return this.fullFetch({
            filter: mdt_client_1.Filter.eq(RouteManager.SCHEMA.routePoint.fields.idRoute, ID_Route)
        }, RouteManager.SCHEMA.routePoint.code);
    }
    fullFetch(query, table) {
        let d = mdt_client_1.m.deferred();
        if (!query.top) {
            query.top = 1000;
        }
        let top = query.top;
        let result = [];
        let run = () => mdt_client_1.Api.fetch(table, query).then(x => {
            if (!x.records)
                d.reject();
            result = result.concat(x.records);
            if (x.records && x.records.length == top) {
                query.skip = (query.skip || 0) + top;
                run();
            }
            else {
                d.resolve(result);
            }
        });
        run();
        return d.promise;
    }
    fetchHolydays(DateBegin, DateEnd) {
        let def = mdt_client_1.m.deferred();
        mdt_client_1.Api.fetchFunction("calendar.GetHolidays", {
            "DateBegin": DateBegin,
            "DateEnd": DateEnd,
            "CountryCode": "RU"
        }).then(x => {
            if (x.records) {
                this.holydays = x.records
                    .map(x => (x.Date ? new Date(x.Date) : null))
                    .filter(d => (0, utils_1.isDateValid)(d));
            }
            def.resolve();
        });
        return def.promise;
    }
    isWorkday(date) {
        return !this.holydays.find(d => (0, utils_1.compareDates)(date, d));
    }
    async getRoutes(ID_Cycle, ID_Positions) {
        let f = RouteManager.SCHEMA.route.fields;
        let routeSchema = RouteManager.SCHEMA.route;
        let select = ["*"];
        let iconPath = mdt_client_1.legacy.list.LabelStyleHelper.getIconPath(routeSchema.code, routeSchema.fields.idStatus);
        if (iconPath)
            select.push(iconPath);
        let labelStylePath = mdt_client_1.legacy.list.LabelStyleHelper.getLabelStylePath(routeSchema.code, routeSchema.fields.idStatus);
        if (labelStylePath)
            select.push(labelStylePath);
        let routeTable = mdt_client_1.legacy.SchemaManagerInstance.get(routeSchema.code);
        return routeTable.$datasource.fetch({
            filter: mdt_client_1.Filter.and(mdt_client_1.Filter.eq(f.idCycle, ID_Cycle), mdt_client_1.Filter.in(f.idPosition, ID_Positions)),
            select
        }, routeTable, {
            method: "POST"
        });
    }
    fetchStatuses() {
        let def = mdt_client_1.m.deferred();
        let routeTable = mdt_client_1.Schema.getObject(RouteManager.SCHEMA.route.code);
        if (!this.statuses) {
            mdt_client_1.legacy.modules.status.StatusManager.fetchStatuses({
                filter: mdt_client_1.Filter.eq(mdt_client_1.legacy.modules.status.statusSchema.table.fields.ID_Object, routeTable.getId())
            }).then(x => {
                this.statuses = {};
                x.records.forEach(r => {
                    this.statuses[r.$id] = r;
                });
                def.resolve(this.statuses);
            });
        }
        else {
            def.resolve(this.statuses);
        }
        return def.promise;
    }
    isReadonly(route) {
        if (!route.$access)
            return true;
        return !(route.$access.BaseLevel & mdt_client_1.SecurityManager.PermissionLevel.Write);
    }
    fetchTotalTime(routeId, DateBegin, DateEnd) {
        return mdt_client_1.Api.fetchFunction("rt.udf_RouteTime", Object.assign({}, mdt_client_1.legacy.ApiUrlHelper.prepareQueryParams(routeId, DateBegin, DateEnd))).then(x => {
            return x.records && x.records[0] ? x.records[0] : null;
        });
    }
    static fetchSettings() {
        return mdt_client_1.Api.fetch("mdt.GlobalVar", {
            filter: mdt_client_1.Filter.startsWith("Code", "ent.routes.")
        }).then(s => {
            s.records.forEach(r => this.setSetting(r));
        });
    }
    static setSetting(record) {
        let code = record.Code.replace("ent.routes.", "");
        if (this.ignoredSettings.includes(code))
            return;
        try {
            let value = JSON.parse(record.Value);
            if (code == "schema") {
                this.SCHEMA = mdt_client_1.legacy.utils.utilscombine(this.SCHEMA, value);
            }
            else {
                this.Settings[code] = value;
            }
        }
        catch (e) {
            console.error(mdt_client_1.Utils.getText(`Invalid settings value for parameter "{code}" in "mdt.GlobalVar". {error}`, {
                code,
                error: e
            }));
        }
    }
    static getUrlParams() {
        let paramCodes = RouteManager.Settings.RouteURLParams;
        return {
            cycleId: mdt_client_1.m.route.param(paramCodes.Cycle),
            positionId: mdt_client_1.m.route.param(paramCodes.Position)
        };
    }
    static setUrlParams(args, replace) {
        let path = mdt_client_1.legacy.URLHelper.removeAllParams(location.href) + mdt_client_1.legacy.utils.getQueryString(args);
        history.pushState(null, null, path);
    }
}
exports.RouteManager = RouteManager;
RouteManager.Settings = {
    TimeTransfer: 30,
    TimeVisit: 50,
    ConfirmationListColIndex: 2,
    DefaultColumnWidth: 100,
    RouteApprovalDefaultFieldColumnWidth: 300,
    RouteApprovalDefaultColumnWidth: 160,
    TimeVisitUpdateDelay: 1000,
    TimeTransferUpdateDelay: 1000,
    RouteURLParams: {
        Cycle: "cycle",
        Position: "position"
    }
};
RouteManager.SCHEMA = {
    route: {
        code: "rt.Route",
        fields: {
            id: "ID",
            idCycle: "ID_Cycle",
            idPosition: "ID_em_Position",
            idStatus: "ID_status_Status",
            timeVisit: "TimeVisit",
            timeTransfer: "TimeTransfer"
        }
    },
    routePoint: {
        code: "rt.RoutePoint",
        fields: {
            idRoute: "ID_Route",
            idOutlet: "ID_Outlet",
            date: "Date",
            sortOrder: "SortOrder"
        }
    },
    outlet: {
        code: "rt.udf_RouteOutlets",
        fields: {
            id: "ID"
        }
    },
    outletData: {
        fields: {
            idOutlet: "ID_Outlet",
            idPosition: "ID_em_Position",
            idCycle: "ID_Cycle"
        }
    },
    cycle: {
        code: "rt.Cycle"
    },
    position: {
        code: "em.Position",
        defaultFieldCode: "EmployeeHistory$"
    },
    procedures: {
        copy: "rt.usp_CopyRoutes"
    }
};
RouteManager.ignoredSettings = ["CacheUpdateTime"];


/***/ }),

/***/ 571:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RouteRowCellTransformer = void 0;
const mdt_client_1 = __webpack_require__(305);
const RouteColumns_1 = __webpack_require__(757);
class RouteRowCellTransformer {
    constructor(routePageCtrl) {
        this.routePageCtrl = routePageCtrl;
    }
    $view(ctrl, ctx) {
        if (ctx.col.$routeColumnType != null &&
            [
                RouteColumns_1.SFRouteColumnType.day,
                RouteColumns_1.SFRouteColumnType.week,
                RouteColumns_1.SFRouteColumnType.timeVisit
            ].includes(ctx.col.$routeColumnType) &&
            !ctrl.routePageCtrl.isReadonly())
            return;
        mdt_client_1.legacy.ui.m.addClass(ctx.td, "inline-read-only");
    }
}
exports.RouteRowCellTransformer = RouteRowCellTransformer;


/***/ }),

/***/ 659:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CopyRouteManager = void 0;
const RouteManager_1 = __webpack_require__(546);
const mdt_client_1 = __webpack_require__(305);
const utils_1 = __webpack_require__(135);
class CopyRouteManager {
    constructor(cycleId, posIds, positionRouteHash, mapping) {
        this.cycleId = cycleId;
        this.positionRouteHash = positionRouteHash;
        this.mapping = mapping;
        this.prevRoutesHash = {};
        const periodsTableCode = "rt.CopyRoutesPeriod_virtual";
        const periodsTable = mdt_client_1.legacy.SchemaManagerInstance.prepare({
            code: periodsTableCode,
            fields: [
                {
                    code: "From",
                    title: mdt_client_1.Utils.getText("From"),
                    type: "date",
                    nullable: false
                },
                {
                    code: "To",
                    title: mdt_client_1.Utils.getText("To"),
                    type: "date",
                    nullable: false
                }
            ]
        });
        mdt_client_1.legacy.SchemaManagerInstance.add(periodsTable);
        this.periodsTable = periodsTable;
        this.table = mdt_client_1.legacy.SchemaManagerInstance.prepare({
            title: "Copy into routes",
            code: CopyRouteManager.tableCode,
            fields: [
                {
                    code: "ID_CycleFrom",
                    title: mdt_client_1.Utils.getText("Cycle"),
                    type: "int",
                    refTableCode: RouteManager_1.RouteManager.SCHEMA.cycle.code,
                    nullable: false
                },
                {
                    code: "ID_CycleTo",
                    type: "int",
                    refTableCode: RouteManager_1.RouteManager.SCHEMA.cycle.code,
                    nullable: false
                },
                {
                    code: "ID_PositionsTemp",
                    title: mdt_client_1.Utils.getText("Positions"),
                    type: "list",
                    refTableCode: RouteManager_1.RouteManager.SCHEMA.position.code,
                    nullable: true
                }
            ]
        });
        this.record = mdt_client_1.legacy.utils.prop(mdt_client_1.legacy.FormCtrl.createRecord({
            ID_CycleFrom: cycleId,
            ID_CycleTo: null,
            ID_PositionsTemp: posIds
        }, this.table, true));
    }
    canOverride(positionId) {
        if (!this.selectedCycle)
            return false;
        let curRoute = this.selectedCycle;
        let routeTable = mdt_client_1.legacy.SchemaManagerInstance.get(RouteManager_1.RouteManager.SCHEMA.route.code);
        return (!curRoute ||
            !!mdt_client_1.legacy.SecurityManagerInstance.record(curRoute, routeTable, mdt_client_1.SecurityManager.PermissionLevel.Delete));
    }
    routeById(id) {
        return this.positionRouteHash[id];
    }
    prepareRecord(rec) {
        let nRec = Object.assign({}, rec);
        nRec["ID_Positions"] = rec["ID_PositionsTemp"]
            .filter(id => this.canOverride(id))
            .join(",");
        delete nRec["ID_PositionsTemp"];
        if (this.mapping) {
            nRec.Mapping = {
                Name: "Mapping",
                Type: "rt.DateMappingType",
                Rows: []
            };
            this.mapping.map(mappingItem => {
                if (mappingItem.From.week) {
                    mappingItem.From.week.map((date, idx) => {
                        const datesArr = [date];
                        const dateTo = mappingItem.To.week && mappingItem.To.week[idx];
                        if (dateTo) {
                            datesArr.push(dateTo);
                            nRec.Mapping.Rows.push(datesArr);
                        }
                    });
                }
                else if (mappingItem.To.date)
                    nRec.Mapping.Rows.push([(0, utils_1.toISO8601DateString)(mappingItem.From.date), (0, utils_1.toISO8601DateString)(mappingItem.To.date)]);
            });
        }
        return nRec;
    }
    isCopyEnabled() {
        if (this.mapping && this.isEmptyMapping())
            return false;
        return this.record()["ID_PositionsTemp"].filter(id => this.canOverride(id)).length;
    }
    isEmptyMapping() {
        return !this.mapping.some(x => x.To.week || x.To.date);
    }
    onCycleUpdate() {
        return this.updatePrevCycleData();
    }
    updatePrevCycleData() {
        let d = mdt_client_1.m.deferred();
        let positions = this.record()["ID_PositionsTemp"];
        let fields = RouteManager_1.RouteManager.SCHEMA.route.fields;
        let routeTable = mdt_client_1.legacy.SchemaManagerInstance.get(RouteManager_1.RouteManager.SCHEMA.route.code);
        let ds = routeTable.$datasource;
        this.prevRoutesHash = {};
        let cycleId = this.record()["ID_CycleTo"];
        this.selectedCycle = cycleId;
        if (cycleId) {
            ds.fetch({
                filter: mdt_client_1.Filter.and(mdt_client_1.Filter.eq(fields.idCycle, cycleId), mdt_client_1.Filter.in(fields.idPosition, positions))
            }, routeTable).then(x => {
                let routes = x.records;
                positions.forEach(posId => {
                    let route = routes.find(route => route[fields.idPosition] == posId);
                    this.prevRoutesHash[posId] = route || null;
                });
                if (this.mapping)
                    this.resetMapping();
                d.resolve();
            });
        }
        else {
            d.resolve();
        }
        return d.promise;
    }
    setPeriodsMapping() {
        let cycle = this.record()["ID_CycleTo$"];
        if (cycle && cycle.DateBegin && cycle.DateEnd) {
            var weekData = (0, utils_1.getWeeksData)(cycle.DateBegin, cycle.DateEnd);
            this.currentCycleWeeks = weekData.map((x, i) => {
                return {
                    week: x,
                    cycleWeekIndex: i
                };
            });
            this.mapping.forEach(x => {
                x.To = {};
                if (x.From.date) {
                    var d = new Date(cycle.DateBegin);
                    d.setDate(d.getDate() + x.From.dateIndexInCycle);
                    if (d <= cycle.DateEnd)
                        x.To.date = d;
                }
                else {
                    x.To.week = weekData[x.From.cycleWeekIndex];
                    if (x.To.week)
                        x.To.cycleWeekIndex = x.From.cycleWeekIndex;
                }
            });
        }
    }
    mappingRecords() {
        return this.mapping;
    }
    matchControlsAvailable() {
        return this.mapping && this.mapping.length;
    }
    matchControlsEditable() {
        return this.record()["ID_CycleTo"];
    }
    getCyclePeriod() {
        let cycle = this.record()["ID_CycleTo$"];
        if (cycle && cycle.DateBegin && cycle.DateEnd)
            return {
                cycleBegin: cycle.DateBegin,
                cycleEnd: cycle.DateEnd,
                periodLikeArray: (0, utils_1.getWeeksData)(cycle.DateBegin, cycle.DateEnd)
            };
    }
    resetMapping() {
        this.setPeriodsMapping();
    }
    selectableWeekDates() {
        return this.currentCycleWeeks || [];
    }
}
exports.CopyRouteManager = CopyRouteManager;
CopyRouteManager.tableCode = "rt.CopyRoutes_virtual";


/***/ }),

/***/ 739:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RouteApprovalCtrl = void 0;
const RouteManager_1 = __webpack_require__(546);
const mdt_client_1 = __webpack_require__(305);
const CopyRouteControl_1 = __webpack_require__(853);
class RouteApprovalCtrl {
    constructor(options) {
        this.options = options;
        this.positionIdProp = mdt_client_1.legacy.utils.prop();
        this.cycleIdProp = mdt_client_1.legacy.utils.prop();
        this.positionRouteHash = {};
        this.statusCache = {};
        this.routeManager = new RouteManager_1.RouteManager();
        this.content = mdt_client_1.legacy.CenteredMessageCtrl(`${mdt_client_1.Utils.getText("Please select cycle and position")}!`);
        // Parse URL Params
        let { cycleId, positionId } = RouteManager_1.RouteManager.getUrlParams();
        this.cycleIdProp(cycleId);
        this.positionIdProp(positionId);
    }
    initContainer(container) {
        let routeTable = mdt_client_1.legacy.SchemaManagerInstance.get(RouteManager_1.RouteManager.SCHEMA.route.code);
        let headerControls = new mdt_client_1.legacy.PageHeaderControls({
            controlsSettings: [
                {
                    code: "cycle",
                    prop: this.cycleIdProp,
                    field: Object.assign(Object.assign({}, mdt_client_1.legacy.SchemaManagerInstance.field(routeTable, RouteManager_1.RouteManager.SCHEMA.route.fields.idCycle)), { code: RouteManager_1.RouteManager.SCHEMA.route.fields.idCycle, nullable: true }),
                    options: Object.assign({ hintSelect: ["DateBegin", "DateEnd"], css: "routes-cycle-picker" }, this.options.cyclePicker)
                },
                {
                    code: "position",
                    prop: this.positionIdProp,
                    field: Object.assign(Object.assign({}, mdt_client_1.legacy.SchemaManagerInstance.field(routeTable, RouteManager_1.RouteManager.SCHEMA.route.fields.idPosition)), { code: RouteManager_1.RouteManager.SCHEMA.route.fields.idPosition, nullable: true }),
                    options: Object.assign({ css: "routes-position-picker" }, this.options.positionPicker)
                }
            ]
        }, {
            onchange: (code, v, v$, r, data = {}) => {
                let { $fetchDisplayValue, $autopick } = data;
                this.updateMainContent($fetchDisplayValue, $autopick);
            }
        });
        this.data = headerControls.record;
        container.zones.header.push(headerControls);
    }
    updateRouteState(replace) {
        let args = {};
        if (this.data.cycle())
            args[RouteManager_1.RouteManager.Settings.RouteURLParams.Cycle] = this.data.cycle();
        if (this.data.position())
            args[RouteManager_1.RouteManager.Settings.RouteURLParams.Position] = this.data.position();
        RouteManager_1.RouteManager.setUrlParams(args, replace);
    }
    updateMainContent($initial, $autopick) {
        if (!$initial && !$autopick) {
            this.updateRouteState($autopick);
        }
        if (this.data.cycle() && this.data.position()) {
            this.positionRouteHash = {};
            this.content = this.createList();
        }
        else {
            this.content = mdt_client_1.legacy.CenteredMessageCtrl(`${mdt_client_1.Utils.getText("Please select cycle and position")}!`);
        }
    }
    getStatuses(route) {
        let statusField = RouteManager_1.RouteManager.SCHEMA.route.fields.idStatus;
        return new Promise(resolve => {
            let cached = this.statusCache[route[statusField]];
            if (cached) {
                resolve(cached);
                return;
            }
            let table = mdt_client_1.legacy.SchemaManagerInstance.get(RouteManager_1.RouteManager.SCHEMA.route.code);
            mdt_client_1.legacy.modules.status.StatusManager.getAvailableStatuses(table, route.$id, route[statusField]).then(statuses => {
                statuses = statuses.filter(s => s.$id != route[statusField]);
                this.statusCache[route[statusField]] = statuses;
                resolve(statuses);
            });
        });
    }
    getStatusButton() {
        let statusField = RouteManager_1.RouteManager.SCHEMA.route.fields.idStatus;
        return {
            title: "Set status",
            enabled: () => {
                let routes = this.getRoutes(this.list.exts.select.rows());
                if (!routes.length)
                    return false;
                let curStatus = routes[0][statusField];
                return routes.every(r => r[statusField] == curStatus);
            },
            command: (b, e) => {
                let routes = this.getRoutes(this.list.exts.select.rows());
                let route = routes[0];
                let dd = new mdt_client_1.legacy.DropdownMenuCtrl({});
                mdt_client_1.legacy.ui.viewState(dd).target = mdt_client_1.legacy.ui.dom.closest(e.target, "A");
                dd.show([{ title: "Loading..." }]);
                this.getStatuses(route).then(statuses => {
                    dd.close();
                    dd.show(statuses.length
                        ? statuses.map(r => (Object.assign(Object.assign({}, mdt_client_1.legacy.modules.status.StatusManager.createStatusButton(r)), { command: () => {
                                mdt_client_1.legacy.modules.status.StatusManager.setStatus(routes, r.$id);
                                this.list.exts.select.clear();
                                this.list.refresh();
                            } })))
                        : [{ title: "There is no available statuses" }]);
                });
            }
        };
    }
    createList() {
        let f = RouteManager_1.RouteManager.SCHEMA.route.fields;
        let table = mdt_client_1.legacy.SchemaManagerInstance.get(RouteManager_1.RouteManager.SCHEMA.position.code);
        const defaultField = table.defauldField;
        this.list = mdt_client_1.legacy.components.simpleList(table, {
            disableRowCache: true,
            events: {
                inited: [list => this.prepareColumns(list)],
                prebound: [
                    data => {
                        let fetchedPositionRecords = mdt_client_1.legacy.list.HierarchyListExtender.flattenRecords(data.records);
                        let posIds = fetchedPositionRecords.map(r => r.$id);
                        if (posIds.length) {
                            this.routeManager
                                .getRoutes(this.data.cycle(), posIds)
                                .then(x => {
                                let routes = x.records;
                                fetchedPositionRecords.forEach(position => {
                                    let route = routes.find(route => route[f.idPosition] == position.$id);
                                    this.positionRouteHash[position.$id] = route || null;
                                });
                            });
                        }
                    }
                ]
            },
            filter: mdt_client_1.Filter.eq(f.id, this.data.position()),
            layout: {
                id: 1,
                columns: [
                    {
                        title: defaultField === null || defaultField === void 0 ? void 0 : defaultField.title,
                        width: RouteManager_1.RouteManager.Settings.RouteApprovalDefaultFieldColumnWidth,
                        code: RouteManager_1.RouteManager.SCHEMA.position.defaultFieldCode
                    },
                    ...(this.options.listColumns || [])
                ]
            }
        }, {
            select: { multi: true },
            designer: false,
            form: {
                add: false
            },
            hierarchy: {
                legacy: true,
                mode: "+",
                buttonExtend: { visible: false },
                parentField: "PositionHistory/ID_PositionParent",
                primaryField: "ID"
            },
            toolbar: {
                buttons: [
                    this.getStatusButton(),
                    {
                        title: "Copy into routes",
                        icon: "copy",
                        command: () => {
                            let copyRouteControl = new CopyRouteControl_1.CopyRouteControl(this.data.cycle(), this.list.exts.select
                                .rows()
                                .map(r => r.$id), this.positionRouteHash);
                            mdt_client_1.legacy.ui.show
                                .modal(copyRouteControl)
                                .then(() => this.list.refresh());
                        },
                        enabled: () => {
                            let sel = this.list.exts.select.rows();
                            return sel.length > 0;
                        }
                    },
                    {
                        title: "Delete routes",
                        icon: "times",
                        enabled: () => {
                            return (this.getRoutes(this.list.exts.select.rows())
                                .length > 0);
                        },
                        class: "link-danger",
                        command: () => {
                            let ids = this.getRoutes(this.list.exts.select.rows()).map(r => r && r.$id);
                            mdt_client_1.legacy.DeleteService
                                .delete(mdt_client_1.legacy.SchemaManagerInstance.get(RouteManager_1.RouteManager.SCHEMA.route.code), ids)
                                .then(() => {
                                this.list.exts.select.clear();
                                this.list.refresh();
                            });
                        }
                    }
                ]
            }
        });
        return this.list;
    }
    getRoutes(positionRows) {
        return positionRows
            ? positionRows
                .map(x => x.$id)
                .map(id => this.positionRouteHash[id])
                .filter(r => !!r)
            : [];
    }
    prepareColumns(list) {
        list.columns().splice(RouteManager_1.RouteManager.Settings.ConfirmationListColIndex, 0, this.createLinkColumn(), this.createRouteStatusColumn());
    }
    createLinkColumn() {
        let valView = (icon, text, aArgs) => {
            return mdt_client_1.legacy.ui.el.a(aArgs, null, (0, mdt_client_1.m)("span", mdt_client_1.legacy.ui.el.icon(icon), (0, mdt_client_1.m)("span", mdt_client_1.Utils.getText(text))));
        };
        return {
            title: mdt_client_1.Utils.getText("Route"),
            width: RouteManager_1.RouteManager.Settings.RouteApprovalDefaultColumnWidth,
            control: new mdt_client_1.legacy.list.CustomColumnCtrl({
                value: (ctx) => {
                    let r = ctx.row;
                    if (!r.$id)
                        return;
                    let route = this.positionRouteHash[r.$id];
                    if (!this.options.routePagePath)
                        throw new Error("Path to route page not set! Please, contact administrator!");
                    let href = `[href='${this.options.routePagePath}${mdt_client_1.legacy.utils.getQueryString({
                        cycle: this.data.cycle(),
                        position: r.$id
                    })}']`;
                    return route === void 0
                        ? valView("sync-alt spin", "Loading...", "")
                        : route == null
                            ? valView("plus-circle", "Create route", href)
                            : valView("external-link-square", "View route", href);
                }
            })
        };
    }
    createRouteStatusColumn() {
        let valView = (ctx) => {
            let r = ctx.row;
            if (!r.$id)
                return;
            let route = this.positionRouteHash[r.$id];
            if (!route)
                return;
            let routeSchema = RouteManager_1.RouteManager.SCHEMA.route;
            let iconPath = mdt_client_1.legacy.list.LabelStyleHelper.getIconPath(routeSchema.code, routeSchema.fields.idStatus);
            let labelStylePath = mdt_client_1.legacy.list.LabelStyleHelper.getLabelStylePath(routeSchema.code, routeSchema.fields.idStatus);
            let icon = iconPath
                ? mdt_client_1.legacy.RecordManagerInstance.valueByPath(route, iconPath)
                : null;
            let labelStyle = labelStylePath
                ? mdt_client_1.legacy.RecordManagerInstance.valueByPath(route, labelStylePath)
                : null;
            return mdt_client_1.legacy.list.LabelStyleCellView(icon, labelStyle, mdt_client_1.legacy.RecordManagerInstance.valueByPath(route, routeSchema.fields.idStatus + "$"));
        };
        return {
            title: mdt_client_1.Utils.getText("Route status"),
            width: RouteManager_1.RouteManager.Settings.RouteApprovalDefaultColumnWidth,
            control: new mdt_client_1.legacy.list.CustomColumnCtrl({
                value: valView
            })
        };
    }
}
exports.RouteApprovalCtrl = RouteApprovalCtrl;


/***/ }),

/***/ 757:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SFRouteColumnType = void 0;
exports.createTimeColumn = createTimeColumn;
exports.createTimeVisitColumn = createTimeVisitColumn;
exports.createWeekColumn = createWeekColumn;
exports.createDayColumn = createDayColumn;
const RouteManager_1 = __webpack_require__(546);
const mdt_client_1 = __webpack_require__(305);
const Formatters_1 = __webpack_require__(942);
const RouteWeekColumn_1 = __webpack_require__(286);
const utils_1 = __webpack_require__(135);
var SFRouteColumnType;
(function (SFRouteColumnType) {
    SFRouteColumnType[SFRouteColumnType["week"] = 0] = "week";
    SFRouteColumnType[SFRouteColumnType["day"] = 1] = "day";
    SFRouteColumnType[SFRouteColumnType["time"] = 2] = "time";
    SFRouteColumnType[SFRouteColumnType["frequency"] = 3] = "frequency";
    SFRouteColumnType[SFRouteColumnType["timeVisit"] = 4] = "timeVisit";
})(SFRouteColumnType || (exports.SFRouteColumnType = SFRouteColumnType = {}));
function createTimeColumn(ctrl) {
    return {
        title: mdt_client_1.Utils.getText("Time"),
        $routeColumnType: SFRouteColumnType.time,
        width: RouteManager_1.RouteManager.Settings.DefaultColumnWidth,
        control: new mdt_client_1.legacy.list.CustomColumnCtrl({
            value: (ctx) => {
                let points = ctx.row.$id
                    ? ctrl.routePointsManager.getPointsByOutlet(ctx.row.$id)
                    : ctrl.routePointsManager.getData();
                if (ctrl.currentDay) {
                    points = points.filter(p => (0, utils_1.compareDates)(p.Date, ctrl.currentDay));
                }
                else if (ctrl.currentWeek != null) {
                    let dates = ctrl.getCurrentWeekData().map(d => (0, utils_1.toISO8601DateString)(d));
                    points = points.filter(p => dates.includes((0, utils_1.toISO8601DateString)(new Date(p.Date))));
                }
                return (0, Formatters_1.formatDuration)(points.reduce((a, b) => a + ctrl.getVisitTime(b), 0) * 60000);
            }
        })
    };
}
function createTimeVisitColumn(ctrl) {
    let vCache = {};
    let ctrlCache = {};
    let getPoint = (id) => ctrl.routePointsManager.getPoint(id, ctrl.getCurrentDay());
    let getValue = (id) => {
        if (vCache[id])
            return vCache[id];
        let p = getPoint(id);
        vCache[id] = p ? p.TimeVisit || RouteManager_1.RouteManager.Settings.TimeVisit : null;
        return vCache[id];
    };
    let getInputCtrl = (id) => {
        if (ctrlCache[id])
            return ctrlCache[id];
        let timeout;
        ctrlCache[id] = new mdt_client_1.legacy.FormlessFieldCtrl(v => {
            let p = getPoint(id);
            if (v === undefined)
                return p ? p.TimeVisit : null;
            if (!p)
                return null;
            v = parseInt(v);
            p.TimeVisit = isNaN(v) ? null : v;
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                ctrl.routeManager.saveRoutePoint(p);
                vCache[id] = undefined;
            }, RouteManager_1.RouteManager.Settings.TimeVisitUpdateDelay);
            return p.TimeVisit;
        }, { code: "TimeVisit", type: "string" }, {
            labelMode: mdt_client_1.legacy.LabelMode.Hidden,
            placeholder: RouteManager_1.RouteManager.Settings.TimeVisit,
            type: "number",
            visible: () => !!getPoint(id),
            min: 1
        });
        return ctrlCache[id];
    };
    let table = mdt_client_1.legacy.SchemaManagerInstance.get(RouteManager_1.RouteManager.SCHEMA.route.code);
    let field = mdt_client_1.legacy.SchemaManagerInstance.field(table, RouteManager_1.RouteManager.SCHEMA.route.fields.timeVisit);
    return {
        title: mdt_client_1.legacy.utils.title(field),
        $routeColumnType: SFRouteColumnType.timeVisit,
        width: RouteManager_1.RouteManager.Settings.DefaultColumnWidth,
        control: new mdt_client_1.legacy.list.CustomColumnCtrl({
            value: (ctx) => {
                if (!ctx.row.$id)
                    return "";
                if (ctrl.isReadonly()) {
                    return getValue(ctx.row.$id);
                }
                mdt_client_1.legacy.ui.m.addClass(ctx.td, "route-col_inline-cell");
                return mdt_client_1.legacy.view(getInputCtrl(ctx.row.$id));
            }
        })
    };
}
function createWeekColumn(idx, weekData, ctrl) {
    return {
        title: (0, Formatters_1.formatWeekTitle)(idx),
        $routeColumnType: SFRouteColumnType.week,
        width: RouteManager_1.RouteManager.Settings.DefaultColumnWidth,
        control: new RouteWeekColumn_1.RouteWeekColumn({
            value: (ctx) => {
                let dates = weekData.map(data => (0, utils_1.toISO8601DateString)(data));
                let points = ctrl.routePointsManager.getPointsByOutlet(ctx.row.$id);
                points = points.filter(r => dates.includes((0, utils_1.toISO8601DateString)(new Date(r.Date))));
                if (!points || !points.length)
                    return "";
                if (points.length == 1)
                    return RouteWeekColumn_1.RouteWeekColumnTemplates.one();
                if (points.length > 1)
                    return RouteWeekColumn_1.RouteWeekColumnTemplates.many("" + points.length);
                return "";
            },
            active: () => !ctrl.routePointsManager.state.pending(),
            onclick: () => {
                ctrl.setWeekIndex(idx);
            },
            onHeadClick: () => {
                ctrl.setWeekIndex(idx);
            },
            isHeadCheckboxChecked: () => ctrl.isWeekSelected(idx),
            onHeadCheckboxClick: () => ctrl.selectWeek(weekData, idx)
        })
    };
}
function createDayColumn(date, dateIndexInCycle, weekIndex, ctrl) {
    return {
        title: (0, Formatters_1.dayWithName)(date),
        $routeColumnType: SFRouteColumnType.day,
        width: RouteManager_1.RouteManager.Settings.DefaultColumnWidth,
        control: new RouteWeekColumn_1.RouteWeekColumn({
            value: (ctx) => {
                let point = ctrl.routePointsManager.getPoint(ctx.row.ID, date);
                return (0, mdt_client_1.m)("", point ? RouteWeekColumn_1.RouteWeekColumnTemplates.day(point.SortOrder) : "");
            },
            active: () => !ctrl.routePointsManager.state.pending(),
            onclick: (ctx) => {
                if (!ctx.row.ID || ctrl.isReadonly())
                    return;
                ctrl.routePointsManager.toggle(ctx.row, date);
                mdt_client_1.legacy.ui.redraw();
            },
            onHeadClick: () => {
                ctrl.setDay(date, true);
            },
            isHeadCheckboxChecked: () => ctrl.isDaySelected(date),
            onHeadCheckboxClick: () => ctrl.selectDay(date, weekIndex, dateIndexInCycle)
        })
    };
}


/***/ }),

/***/ 815:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DateTimeCtrl = exports.DateTimeControl = exports.DateTimeControlType = void 0;
const mdt_client_1 = __webpack_require__(305);
const Formatters_1 = __webpack_require__(942);
const utils_1 = __webpack_require__(135);
var DateTimeControlType;
(function (DateTimeControlType) {
    DateTimeControlType[DateTimeControlType["date"] = 0] = "date";
    DateTimeControlType[DateTimeControlType["week"] = 1] = "week";
})(DateTimeControlType || (exports.DateTimeControlType = DateTimeControlType = {}));
class DateTimeControl {
    constructor(data, options, ctx) {
        this.data = data;
        this.options = options;
        this.ctx = ctx;
        if (options.type === DateTimeControlType.date)
            this.control = new mdt_client_1.legacy.FormlessFieldCtrl(v => {
                if (v === undefined)
                    return this.data.date || unselectedObject;
                this.data.date = v;
                ctx.row.$rendered = false;
                return this.data.date;
            }, {}, {
                control: mdt_client_1.legacy.DateTextFieldCtrl,
                labelMode: mdt_client_1.legacy.LabelMode.Hidden,
                disableDayFn: (date) => {
                    return (0, utils_1.toISO8601DateString)(date) < (0, utils_1.toISO8601DateString)(options.cyclePeriod.cycleBegin) || (0, utils_1.toISO8601DateString)(date) > (0, utils_1.toISO8601DateString)(options.cyclePeriod.cycleEnd);
                },
                customControl: new DateTimeCtrl(this.data, {
                    cyclePeriod: options.cyclePeriod,
                    cyclePeriods: options.cyclePeriods
                }),
                readonly: options.readonly(),
            });
        else
            this.weekControl = new DateTimeCtrl(this.data, {
                cyclePeriod: options.cyclePeriod,
                cyclePeriods: options.cyclePeriods
            });
    }
    selectPeriodItem(index, item) {
        this.data = Object.assign({}, item);
        this.weekControl.data = this.data;
        this.ctx.row.To = Object.assign({}, item);
        this.ctx.row.$rendered = false;
    }
}
exports.DateTimeControl = DateTimeControl;
mdt_client_1.legacy.viewer(DateTimeControl, ctrl => {
    var o = ctrl.options;
    if (o.type === DateTimeControlType.date)
        return mdt_client_1.legacy.view(ctrl.control);
    return (0, mdt_client_1.m)(".select-wrapper", (0, mdt_client_1.m)(".selected-info", mdt_client_1.legacy.view(ctrl.weekControl)), o.cyclePeriod ? (0, mdt_client_1.m)(".select-icon", {
        onclick: (e) => {
            if (o.readonly())
                return;
            let dd = new mdt_client_1.legacy.DropdownMenuCtrl();
            mdt_client_1.legacy.ui.viewState(dd).target = e.target;
            dd.show(o.selectableWeekDates().map((x, i) => {
                return {
                    control: new DateTimeCtrl(x, {
                        onclick: () => {
                            ctrl.selectPeriodItem(i, x);
                            dd.close();
                        },
                        cyclePeriods: ctrl.options.cyclePeriods
                    }),
                    wrapTag: "a"
                };
            }));
        }
    }, mdt_client_1.legacy.ui.el.icon("calendar")) : null);
});
class DateTimeCtrl {
    constructor(data, options = {}) {
        this.data = data;
        this.options = options;
    }
}
exports.DateTimeCtrl = DateTimeCtrl;
function getWeekIndexInCycle(period, date) {
    return period.findIndex(d => d.find(d => (0, utils_1.compareDates)(d, date)));
}
mdt_client_1.legacy.viewer(DateTimeCtrl, ctrl => {
    var d = ctrl.data;
    var o = ctrl.options;
    if (d.date && o.cyclePeriod)
        d.cycleWeekIndex = getWeekIndexInCycle(o.cyclePeriod.periodLikeArray, d.date);
    return (0, mdt_client_1.m)(`${o.tag}.select-wrapper`, {
        onclick: () => o.onclick && o.onclick()
    }, !d.date && !d.week ? mdt_client_1.Utils.getText("Not selected")
        : (0, mdt_client_1.m)("", (0, mdt_client_1.m)("", d.date
            ? (0, Formatters_1.dayWithName)(d.date)
            : (0, Formatters_1.formatWeekDates)(d.week)), (0, mdt_client_1.m)("", `${(0, Formatters_1.formatYearWeekTitle)(d.date || d.week[0], o.cyclePeriods)} (${(0, Formatters_1.formatWeekTitle)(d.cycleWeekIndex)})`)), o.cyclePeriod && d.date ? (0, mdt_client_1.m)('.select-icon.calendar', null, mdt_client_1.legacy.ui.el.icon("calendar")) : null);
});
const unselectedObject = {
    toDateString: () => mdt_client_1.Utils.getText("Not selected")
};


/***/ }),

/***/ 825:
/***/ ((module) => {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ 853:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CopyRouteControl = void 0;
const RouteManager_1 = __webpack_require__(546);
const CopyRouteManager_1 = __webpack_require__(659);
const mdt_client_1 = __webpack_require__(305);
const MatchControls_1 = __webpack_require__(815);
let FormManagerEventRegistred = false;
const fullWidthClass = "routes-copy-to";
class CopyRouteControl {
    constructor(cycleId, posIds, positionRouteHash, mapping, onClose, cyclePeriods) {
        this.mapping = mapping;
        this.matchControls = {};
        this.prepareLayout = (layout) => {
            const prepareHint = (layout) => {
                const hintCol = layout
                    .cols()
                    .find((col) => col.options.content.startsWith("**Внимание! Для копирования маршрутов"));
                const hintText = this.mapping
                    ? "**Внимание! Для копирования маршрутов необходимо выполнить следующие действия**\n - Перейти в маршрут, **из** которого планируется произвести копирование\n - Выбрать дни или недели, которые планируется скопировать \n - Нажать кнопку `Скопировать`\n - Выбрать Цикл, **в** который необходимо произвести копирование\n - Сопоставить дни или недели друг с другом\n - Нажать кнопку `Скопировать`\n\n*Можно копировать из любого Цикла в любой Цикл в прошлом или будущем*"
                    : "**Внимание! Для копирования маршрутов необходимо выполнить следующие действия**\n - Перейти в маршрут, **из** которого планируется произвести копирование\n - Нажать кнопку `Скопировать`\n - Выбрать Цикл, **в** который необходимо произвести копирование\n - Нажать кнопку `Скопировать`\n\n*Можно копировать из любого Цикла в любой Цикл в прошлом или будущем*";
                if (hintCol)
                    hintCol.options.content = hintText;
            };
            var l = new mdt_client_1.legacy.LayoutBuilder(layout)
                .updateFieldOptions("ID_CycleFrom", (col) => {
                col.options.visible = false;
            })
                .updateFieldOptions("ID_CycleTo", (col) => {
                if (!this.mapping)
                    col.options.filter = () => mdt_client_1.Filter.ne("ID", this.copyManager.cycleId);
                col.options.hintSelect = ["DateBegin", "DateEnd"];
            })
                .updateFieldOptions("ID_PositionsTemp", (col) => {
                col.options.css = fullWidthClass;
                col.options.control = "grid";
                col.options.listOptions = {
                    events: {
                        inited: [this.preparePositionsListColumns]
                    }
                };
                col.options.listExtenders = {
                    toolbar: false,
                    designer: false
                };
            });
            prepareHint(l);
            if (this.copyManager.matchControlsAvailable()) {
                if (!this.periodsList) {
                    this.periodsList = new mdt_client_1.legacy.ListCtrl(this.copyManager.periodsTable, {
                        root: true,
                        records: this.copyManager.mappingRecords(),
                        layout: {
                            columns: ["From", "To"].map((f) => {
                                return {
                                    title: mdt_client_1.Utils.getText(f),
                                    control: new mdt_client_1.legacy.list.CustomColumnCtrl({
                                        value: (ctx) => {
                                            var ctrl = this.getDateTimeControl(ctx.row, f, ctx, f === "From");
                                            return mdt_client_1.legacy.view(ctrl);
                                        }
                                    })
                                };
                            })
                        }
                    }, {
                        designer: false
                    });
                }
                if (!mdt_client_1.legacy.LayoutBuilder.find(l.layout, (i) => i.$system && i.type == "periodsList")) {
                    l.add({
                        type: "markdown",
                        options: {
                            content: mdt_client_1.Utils.getText("Matching periods")
                        },
                        $system: true
                    });
                    l.add({
                        width: 12,
                        control: {
                            $view: () => (0, mdt_client_1.m)("." + fullWidthClass, mdt_client_1.legacy.view(this.periodsList))
                        },
                        $system: true,
                        type: "periodsList"
                    });
                }
            }
        };
        this.preparePositionsListColumns = (list) => {
            this.positionsList = list;
            list.columns().splice(RouteManager_1.RouteManager.Settings.ConfirmationListColIndex, 0, this.createColumn());
        };
        this.copyManager = new CopyRouteManager_1.CopyRouteManager(cycleId, posIds, positionRouteHash, mapping);
        this.routeDataManager = new RouteManager_1.RouteManager();
        this.cyclePeriods = cyclePeriods;
        if (!FormManagerEventRegistred) {
            mdt_client_1.legacy.FormLayoutManager.events.itemCreated.push((col, field) => {
                if (field && field.table.code == CopyRouteManager_1.CopyRouteManager.tableCode)
                    col.width = 12;
            });
            FormManagerEventRegistred = true;
        }
        this.content = new mdt_client_1.legacy.FormCtrl(this.copyManager.table, null, {
            record: this.copyManager.record,
            datasource: this.routeDataManager.copyRoutesDataSource({
                prepareRecord: (rec) => this.copyManager.prepareRecord(rec)
            }),
            primaryButton: {
                title: "routes:Copy",
                icon: "copy",
                type: "primary",
                enabled: () => this.copyManager.isCopyEnabled()
            },
            events: {
                layout: {
                    begin: [this.prepareLayout]
                },
                updated: [
                    (field) => {
                        field.code == "ID_CycleTo" &&
                            this.copyManager.onCycleUpdate().then(() => {
                                this.matchControls = {};
                                [this.periodsList, this.positionsList].forEach((list) => {
                                    list && list.rows().forEach((r) => (r.$rendered = null));
                                });
                            });
                    }
                ],
                closed: [() => onClose && onClose()]
            }
        });
    }
    initContainer(container, options) {
        this.content.initContainer(container, options);
    }
    createColumn() {
        return {
            title: mdt_client_1.Utils.getText("Action"),
            control: new mdt_client_1.legacy.list.CustomColumnCtrl({
                value: (ctx) => {
                    if (!ctx.row || !ctx.row.$id)
                        return;
                    let id = ctx.row.$id;
                    let curRoute = this.copyManager.routeById(id);
                    let canOverride = this.copyManager.canOverride(id);
                    let text = "";
                    let title = "";
                    let classes = ".label";
                    if (!canOverride) {
                        const hintText = this.copyManager.selectedCycle
                            ? "Route on target cycle already exist and can't be deleted"
                            : "No cycle selected for copy";
                        title = mdt_client_1.Utils.getText(hintText);
                        text = mdt_client_1.Utils.getText("Inpossible to copy");
                        classes += ".label-warning";
                    }
                    else if (this.copyManager.prevRoutesHash[id]) {
                        title = mdt_client_1.Utils.getText("Route will be copied");
                        text = mdt_client_1.Utils.getText("routes:Copy");
                        classes += ".label-primary";
                    }
                    else if (this.copyManager.prevRoutesHash[id] === null) {
                        title = mdt_client_1.Utils.getText("There is no route on this cycle for position");
                        text = mdt_client_1.Utils.getText("No route");
                        classes += ".label-warning";
                    }
                    return (0, mdt_client_1.m)("span" + classes, { title }, text);
                }
            })
        };
    }
    getDateTimeControl(row, fieldCode, ctx, readonly) {
        var from = row.From.date || row.From.cycleWeekIndex;
        var ctrlType = row.From.date ? MatchControls_1.DateTimeControlType.date : MatchControls_1.DateTimeControlType.week;
        if (!this.matchControls[from])
            this.matchControls[from] = {};
        if (!this.matchControls[from][fieldCode]) {
            var control = readonly
                ? new MatchControls_1.DateTimeCtrl(row[fieldCode], { cyclePeriods: this.cyclePeriods })
                : new MatchControls_1.DateTimeControl(row[fieldCode], {
                    type: ctrlType,
                    readonly: () => !this.copyManager.matchControlsEditable(),
                    cyclePeriod: this.copyManager.getCyclePeriod(),
                    cyclePeriods: this.cyclePeriods,
                    selectableWeekDates: () => this.copyManager.selectableWeekDates()
                }, ctx);
            this.matchControls[from][fieldCode] = control;
        }
        return this.matchControls[from][fieldCode];
    }
}
exports.CopyRouteControl = CopyRouteControl;


/***/ }),

/***/ 857:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotBoundRowTransformer = void 0;
const mdt_client_1 = __webpack_require__(305);
class NotBoundRowTransformer {
    constructor(routePageCtrl) {
        this.routePageCtrl = routePageCtrl;
    }
    $view(ctrl, ctx) {
        let id = ctx.row.$id;
        if (!ctx.row.$id)
            return;
        let isNotBound = ctrl.routePageCtrl.isNotBound(id);
        if (isNotBound)
            mdt_client_1.legacy.ui.m.addClass(ctx.tr, "route-row_is-not-bound");
    }
}
exports.NotBoundRowTransformer = NotBoundRowTransformer;


/***/ }),

/***/ 865:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(825);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(540);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(113);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_2_use_2_module_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(18);

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_2_use_2_module_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_2_use_2_module_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_2_use_2_module_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_2_use_2_module_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals : undefined);


/***/ }),

/***/ 942:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatWeekTitle = formatWeekTitle;
exports.formatWeekDates = formatWeekDates;
exports.formatDayTitle = formatDayTitle;
exports.formatDay = formatDay;
exports.formatDuration = formatDuration;
exports.dayWithName = dayWithName;
exports.formatYearWeekTitle = formatYearWeekTitle;
const mdt_client_1 = __webpack_require__(305);
const utils_1 = __webpack_require__(135);
function formatWeekTitle(idx) {
    return `${(0, utils_1.romanize)(idx + 1)} ${mdt_client_1.Utils.getText("week")}`;
}
function formatWeekDates(weekDays) {
    if (!weekDays[0])
        return '';
    let beginDate = weekDays[0];
    let endDate = weekDays[weekDays.length - 1];
    return `${formatDay(beginDate)} - ${formatDay(endDate)}`;
}
function formatDayTitle(date) {
    return mdt_client_1.Utils.getText(utils_1.shortDayNames[date.getDay()]);
}
function formatDay(date) {
    return `${date.getDate()} ${mdt_client_1.Utils.getText(utils_1.shortMonthNames[date.getMonth()]).toLowerCase()}`;
}
function formatDuration(duration) {
    let v = (0, utils_1.getTimeValues)(duration);
    let h = v.days * 24 + v.hours;
    return h || v.minutes ? `${mdt_client_1.legacy.utils.pad2(h)}:${mdt_client_1.legacy.utils.pad2(v.minutes)}` : "";
}
function dayWithName(date) {
    return `${formatDayTitle(date)}, ${formatDay(date)}`;
}
function formatYearWeekTitle(date, cyclePeriods) {
    let weekNumber = -1;
    if (!cyclePeriods)
        return;
    cyclePeriods.forEach((period) => {
        if (date >= period.DateBegin && date <= period.DateEnd) {
            weekNumber = period.NumberInYear;
            return;
        }
    });
    return `${weekNumber} нед ${date.getFullYear()}`;
}


/***/ }),

/***/ 980:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RouteManagementPage = void 0;
const mdt_client_1 = __webpack_require__(305);
const RouteManagementCtrl_1 = __webpack_require__(198);
class RouteManagementPage extends RouteManagementCtrl_1.RouteManagementCtrl {
    constructor(node) {
        let settings;
        try {
            settings = node.controlTemplate
                ? JSON.parse(node.controlTemplate)
                : {};
        }
        catch (e) {
            console.log("Warning: wrong navigation node config!", e);
        }
        settings.cyclePicker = Object.assign({ autopick: {
                sorting: [{ path: "DateBegin", asc: true }],
                filter: mdt_client_1.Filter.ge("DateBegin", new Date())
            }, searchOperation: "contains" }, settings.cyclePicker);
        settings.positionPicker = Object.assign({ autopick: {
                sorting: [{ path: "ID", asc: false }],
                filter: {
                    op: "eq",
                    p1: "EmployeeHistory/ID_Employee/ID_mdt_Principal",
                    p2: "ID_CURRENT_USER"
                }
            }, searchOperation: "contains" }, settings.positionPicker);
        super(Object.assign({ table: mdt_client_1.legacy.SchemaManagerInstance.get(node.id_Object) }, settings));
    }
}
exports.RouteManagementPage = RouteManagementPage;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it uses a non-standard name for the exports (exports).
(() => {
var exports = __webpack_exports__;
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const RouteManager_1 = __webpack_require__(546);
const mdt_client_1 = __webpack_require__(305);
const RouteManagementPage_1 = __webpack_require__(980);
const RouteApprovalPage_1 = __webpack_require__(233);
__webpack_require__(865);
(0, mdt_client_1.registerModule)(() => {
    mdt_client_1.Navigation.registerPageCtrl(RouteManagementPage_1.RouteManagementPage, 'RouteManagementPage');
    mdt_client_1.Navigation.registerPageCtrl(RouteApprovalPage_1.RouteApprovalPage, 'RouteApprovalPage');
    if (mdt_client_1.SecurityManager.getUser().isAnonymous)
        return;
    RouteManager_1.RouteManager.fetchSettings();
});

})();

/******/ })()
;
//# sourceMappingURL=index.js.map